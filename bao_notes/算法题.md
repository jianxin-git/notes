

## LeetCode





### 题解汇总

[宫水三叶的刷题日记](https://github.com/SharingSource/LogicStack-LeetCode/wiki)











## 算法题



### 反转链表

```c
void reverseList(pNode *head)
{
    pNode next, cur, prev;
    if (*head == NULL || (*head)->next == NULL)
        return;
    cur = *head;
    next = cur->next;
    prev = NULL;
    while (next){
        cur->next = prev;
        prev = cur;
        cur = next;
        next = next->next;
    }
    cur->next = prev;
    *head = cur;
}

// 基于递归实现
pNode reverseList_reverse(pNode head)
{
    pNode current_head, head_next;
    if (head == NULL)
        return NULL;
     
    if (head->next == NULL)//边界条件
        return head;
    else{
        current_head = head;		//记下当前的头结点a0
        head_next = head->next;		//记下当前头结点后面的结点a1
        head = reverseList_reverse(head_next);	//返回(a1...an)逆转后的头结点
        head_next->next = current_head;			//用逆转后的尾结点指向原来的头结点a0
        current_head->next = NULL;				//将a0的next域置零
    }
    return head;	//返回a0，a0是反转后的链尾
}
```



### 判断链表是否有环

判断一个链表是否有环，有的话返回环的起点，否则返回null

```java
public class Solution {
    public Node hasCycle(Node head) {
        if(head == null) return null;
        Node fast = head;
        Node slow = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast) { // 快慢指针相遇说明有环
                // 计算环的长度
                // 一个指针不动，另一个指针每次移动一个节点，
                // 再次相遇时移动的次数就是环的长度
                int len = 0;
                do {
                    ++len;
                    fast = fast.next;
                } while(slow != fast);
                
                // 一个指针比另一个指针先走环的长度的步数，
                // 再次相遇时的节点就是环的起点
                Node first = head;
                while(len -- > 0) {
                    first = first.next;
                }

                Node second = head;
                while(second != first) {
                    second = second.next;
                    first = first.next;
                }

                return second;
            }
        }
        return null;
    }
}
```



### 最低公共祖先节点

求二叉树中A，B两个节点的最低公共祖先节点

```c
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root) 
        return NULL;//如果当前节点为NULL说明走到了叶节点都没有找到两个节点中的其中一个
    if (root == p || root == q) 
        return root;//如果当前节点为p,q之中的一个，那么返回当前找到的节点中的一个

    TreeNode *L = lowestCommonAncestor(root->left, p, q);
    //左子树中是否能找到p,q中的一个节点
    TreeNode *R = lowestCommonAncestor(root->right, p, q);
    if (L && R) 
        return root;  //如果当前节点左右节点都各找到一个，那么返回当前节点
    return L ? L : R; //只在左节点或者右节点找到一个，说明还有一个节点是在当前节点的下面
    }
};

```



### 连续子数组的最大和



**暴力枚举**

```java
	public int maxSumOfSubArray(int[] A, int n) {
        int best = A[0];
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int sum = 0;
                for(int k=i;k<=j;k++) {
                    sum += A[k];
                }
                best = Math.max(best, sum);
            }
        }
        return best;
    }
```



**使用前缀和**

```java
	public int maxSumOfSubArray(int[] A, int n) {
        int S[] = new int[n];
        S[0] = A[0];
        for (int i = 1; i < n; i++) {
            S[i] = S[i - 1] + A[i];
        }
        int best = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                best = Math.max(best, S[j] - (i == 0 ? 0 : S[i - 1]));
            }
        }
        return best;
    }
```



**使用分治法**

```java
	public int maxSumOfSubArray(int[] A, int n) {
        return maxSum(A, 0, n);
    }

    int maxSum(int[] A, int x, int y) {
        if (y - x == 1) return A[x]; // 只有一个元素，直接返回
        int m = x + (y - x) / 2; // 划分为[x,m)和[m,y)
        int maxs = Math.max(maxSum(A,x,m), maxSum(A,m,y)); // 递归求解
        int v = 0, L = A[m-1];
        for(int i=m-1; i>= x; i--) { 	// 分界点往左的最大连续和L
            L = Math.max(L, v+A[i]);
        }
        v = 0;
        int R=A[m];
        for(int i=m; i< y; i++) { 		// 分界点往右的最大连续和R
            R = Math.max(R, v+A[i]);
        }
        return Math.max(maxs, L+R);
    }
```









### 扔鸡蛋问题

两个软硬程度一样但未知的鸡蛋，它们有可能都在一楼就摔碎，也可能从一百层楼摔下来没事。有座100层的建筑，要你用这两个鸡蛋通过最少的次数确定哪一层是鸡蛋可以安全落下的最高位置。可以摔碎两个鸡蛋

http://blog.csdn.net/joylnwang/article/details/6769160

这样的问题简记为W(n,k)，其中n代表可用于测试的鸡蛋数，k代表被测试的楼层数。对于问题W(2,36)我们可以如此考虑，将第1颗鸡蛋，在第i层扔下（i可以为1～k的任意值），如果碎了，则我们需要用第2颗鸡蛋，解决从第1层到第i-1层楼的子问题W(1,i-1)，如果这颗鸡蛋没碎，则我们需要用这两颗鸡蛋，解决从i+1层到第36层的子问题W(2,36-i)，解决这两个问题，可以分别得到一个尝试次数p，q，我们取这两个次数中的较大者(假设是p)，与第1次在i层执行测试的这1次相加，则p+1就是第一次将鸡蛋仍在i层来解决W(2，36)所需的最少测试次数次数ti。对于36层楼的问题，第一次，我们可以把鸡蛋扔在36层中的任何一层，所以可以得到36中解决方案的测试次数T{t1,t2,t3,……,t36}，在这些结果中，我们选取最小的ti，使得对于集合T中任意的值tj(1<=j<=36,j!=i)，都有ti<=tj，则ti就是这个问题的答案。用公式来描述就是W(n, k) = 1 + min{max(W(n -1, x -1), W(n, k - x))}, x in {2, 3, ……，k}，其中x是第一次的测试的楼层位置。

其中W(1,k) = k（相当于1颗鸡蛋测试k层楼问题），W(0,k) = 0，W(n, 0) = 0

https://gist.github.com/sing1ee/5971946

http://www.raychase.net/1374





### 比较重量

http://www.nowcoder.com/questionTerminal/ac27e60e63b549d6a9b59f815d9bc6e2

小明陪小红去看钻石，他们从一堆钻石中随机抽取两颗并比较她们的重量。这些钻石的重量各不相同。在他们比较了一段时间后，它们看中了两颗钻石g1和g2。现在请你根据之前比较的信息判断这两颗钻石的哪颗更重。

给定两颗钻石的编号g1,g2，编号从1开始，同时给定关系数组vector，其中元素为一些二元组，第一个元素为一次比较中较重的钻石的编号，第二个元素为较轻的钻石的编号。最后给定之前的比较次数n。请返回这两颗钻石的关系，若g1更重返回1，g2更重返回-1，无法判断返回0。输入数据保证合法，不会有矛盾情况出现。



```java
public class Cmp {
    public int cmp(int g1, int g2, int[][] records, int n) {
        Map<Integer, ArrayList<Integer>> ans = 
                                new HashMap<Integer, ArrayList<Integer>>();
        int len = records.length;

        //把比同一个“轻的”放在一个List中
        for(int i=0; i<len; ++i){
            if(ans.get(records[i][0]) == null) {
                ArrayList<Integer> list = new ArrayList<Integer>();
                list.add(records[i][1]);
                ans.put(records[i][0], list);
            } else {
                ans.get(records[i][0]).add(records[i][1]);
            }
        }

        if(judge(g1, g2, ans)){
            return 1;
        } else if(judge(g2, g1, ans)){
            return -1;
        }

        return 0;
    }

    public boolean judge(int g1, int g2, Map<Integer, ArrayList<Integer>> ans){
        LinkedList<Integer> list = new LinkedList<Integer>();
        Map<Integer, Boolean> mark = new HashMap<Integer, Boolean>(); //记录是否遍历过

        list.addFirst(g1);

        while(!list.isEmpty()){
            int cur = list.pollFirst();
            mark.put(cur, true);

            if(cur == g2)
                return true; 
            ArrayList<Integer> list2 = ans.get(cur);//取出的是比cur轻的

            if(list2 != null){ //需要判断是否为空
                for(int i=0; i<list2.size(); i++){
                    if(mark.get(list2.get(i))==null || mark.get(list2.get(i))==false){
                        list.addLast(list2.get(i));
                    }
                }
            }

        }
        return false;
    }
}
```



### 最大差值

有一个长为n的数组A，求满足0≤a≤b<n的A[b]-A[a]的最大值。

给定数组A及它的大小n，请返回最大差值。

测试样例：

[10,5],2

返回：0

```java
// 关键在于要记录遍历过元素的最小值
public class LongestDistance {
    public int getDis(int[] A, int n){
        int dis=0;
        if(n>1){
            int min=A[0];
            for(int i=1;i<n;i++){
                if(A[i]-min > dis){
                    dis = A[i]-min;
                }
                if(min > A[i]){ //最重要的是更新最小值
                    min = A[i];
                }
            }
        }
        return dis;
    }
}
```



### 幸运袋子

http://www.nowcoder.com/test/question/done?tid=4162988&qid=45839

一个袋子里面有n个球，每个球上面都有一个号码(拥有相同号码的球是无区别的)。如果一个袋子是幸运的当且仅当所有球的号码的和大于所有球的号码的积。

例如：如果袋子里面的球的号码是{1, 1, 2, 3}，这个袋子就是幸运的，因为1 + 1 + 2 + 3 > 1 * 1 * 2 * 3

你可以适当从袋子里移除一些球(可以移除0个，但是别移除完)，要使移除后的袋子是幸运的。现在让你编程计算一下你可以获得的多少种不同的幸运的袋子。

 

直接考虑有几个组合是“幸运的”，不要从移除的角度去考虑。

```java
// 需要对nums先排序
private static int find(int[] nums, int index, long sum, long multi) {
    int count = 0;
    for(int i=index; i<nums.length; i++) {
        sum += nums[i];
        multi *= nums[i];
        if(sum > multi)
            count += 1 + find(nums, i+1, sum, multi);
        else if(nums[i] == 1) 
            //1的话对加有作用，对乘相当于没作用，所以后面还是有可能满足条件
            count += find(nums, i+1, sum, multi);
        else
            break; //因为已经排过序，如果在某个数不成立，后面的数越大越不可能成立，所以直接break;
        
        sum -= nums[i];
        multi /= nums[i];
        while (i<nums.length-1 && nums[i]==nums[i+1]) //相同的元素直接跳过
            i++;
    }
    return count;
}
```



### 逆序数对

在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序数对。一个排列中逆序的总数就称为这个排列的逆序数。如{2，4，3，1}中，2和1，4和3，4和1，3和1是逆序数对，因此整个数组的逆序数对个数为4，现在给定一数组，要求统计出该数组的逆序数对个数。

计算数列的逆序数对个数最简单的方便就最从前向后依次统计每个数字与它后面的数字是否能组成逆序数对。

这种方法用到了双循环，时间复杂度为O(N^2)



可以从归并排序中统计出逆序数对

```c

int g_nCount;
void mergearray(int a[], int first, int mid, int last, int temp[])
{
	int i = first, j = mid + 1; 
    int m = mid,   n = last;
    int k = 0;

	while (i <= m && j <= n) //a[i] 前面的数  a[j] 后面的数
	{
		if (a[i] < a[j])
			temp[k++] = a[i++];
		else
		{
			temp[k++] = a[j++];
			//a[j]和前面每一个数都能组成逆序数对
			g_nCount += m - i + 1;
		}
	}

	while (i <= m)
		temp[k++] = a[i++];

	while (j <= n)
		temp[k++] = a[j++];

	for (i = 0; i < k; i++)
		a[first + i] = temp[i];
}
void mergesort(int a[], int first, int last, int temp[])
{
	if (first < last)
	{
	  	int mid = (first + last) / 2;
		mergesort(a, first, mid, temp);    //左边有序
		mergesort(a, mid + 1, last, temp); //右边有序
	    mergearray(a, first, mid, last, temp); //再将二个有序数列合并
	 }
}

bool MergeSort(int a[], int n)
{
	int *p = new int[n];
	if (p == NULL)
		return false;
	mergesort(a, 0, n - 1, p);
	 return true;
}

int main()
{   
    const int MAXN = 8;
	int a[MAXN] = {1, 7, 2, 9, 6, 4, 5, 3};

	g_nCount = 0;
	MergeSort(a, MAXN);
	printf("逆序数对为: %d\n", g_nCount);
	return 0;
}
```



### 数组中两个数只出现过一次

数组中除了两个数只出现过一次，其他的均出现过两次，请找出这两个只出现过一次的数

例如:{10,9,8,7,6,6,7,8,9,10,5,5,4,3};

4和3只出现过一次,请找出出现过一次的数。

http://blog.csdn.net/cxming007/article/details/23746819

对于只有一个出现过一次的数字可以采用异或来获取。如果我们能将这两个只出现过一次的数字划分开，对划分开的两个序列行进异或，那么就可以等到的我们想要找的两个数。

第一步：需要找到一个条件，用于区分出两个出现过一次的数。

```java
public static Integer findOnlyNum1(int[] array){  
    int result = 0;  
    for(int i=0; i<array.length; i++){  
        result ^= array[i];  
    }  
    return result;  
}  
```

第二步：找出他们的不同之处。异或按位操作是相同的为0 ，不同的为1，那么这两个数异或的结果转换成2进制时，低位出现第一个1的位置索引就可以区分他们了。

```java
String binaryResult = Integer.toBinaryString(result);  
int index = binaryResult.length() - (binaryResult.lastIndexOf("1")+1);  
```



第三步：在index位为1的分为一组，为0的分为一组，将序列划分为两个序列。

```java
int result1 = 0;  
int result2 = 0;  
for(int i=0; i<array.length; i++){  
    if(((array[i]>>index)&1)==1){  
        result1 ^= array[i];  
    }else{  
        result2 ^= array[i];  
    }  
}
```



### 首次出现连续n个正面

平均需要抛掷多少次硬币，才会首次出现连续的 n 个正面。

设出现连续k次正面的期望是a[k]

则出现连续k+1次正面的期望为a[k+1]

在出现连续k次正面后，有下面几种情况：

i) 下一个是正面，概率1/2，总次数a[k]+1;

ii)下一个是反面，概率1/2，则接下来平均仍需a[k+1]；

因此 a[k+1]= (a[k]+1) / 2 + (a[k]+1+a[k+1]) / 2

整理得 (a[k+1]+2) / (a[k]+2)=2

a =(a[1]+2) * 2^(n-1) - 2

显然 a[1]=2; a=2^(n+1)-2



### 倒水问题



有装满水的6升的杯子、空的3升杯子和1升杯子，3个杯子中都没有刻度。在不使用其他道具的情况下，是否可以量出4升的水呢?

答案：是可以的，(6,0,0) -> (3,3,0) -> (3,2,1) -> (4,2,0)

对于更一般性的问题：设3个杯子的容量分别为a,b,c，最初只有第3个杯子装满了c升水，其他两个杯子为空。最少需要倒多少升水オ能让某一个杯子中的水有d升呢？如果无法做到恰好d升，就让某一个杯子里的水是d'升，其中d'<d并且尽量接近d。(1≤a,b,c,d≤200)。要求输出最少的倒水量和目标水量(d或者d')。



**分析**：假设在某一时刻，第1个杯子中有v0升水，第2个杯子中有V1升水，第3个杯子中有v2升水，称当时的系统状态为(v0,v1,v2)。把“状态”想象成图中的结点，可以得到如图所示的状态图(state graph)。

<img src="algorithm/1607090689000.png" alt="1607090689000" style="zoom:40%;" />

由于无论如何倒，杯子中的水量都是整数，因此第3个杯子的水量最多只有0,1,2,...,c共c+1种可能；同理，第2个杯子的水量一共只有b+1种可能，第1个杯子一共只有a+1种可能，因此理论上状态最多有(a+1)(b+1)(c+1)种可能性（根据a,b,c的取值限定最多有201\^3种可能）。但是由于水的总量是固定的，因此实际的状态201\^2种。

注意：本题的目标是倒的水量最少，而不是步数最少。实际上，水量最少时步数不一定最少。因此每次不是取出步数最少的结点进行扩展，而是取出水量最少的结点进行扩展。下面的代码把状态（三元组）和dist合起来定义为了一个Node类型，是一种常见的写法。如果要打印路径，需要把访问过的所有结点放在一个nodes数组中，然后在Node中加一个变量fa，表示父结点在nodes数组中的下标，而在队列中只存结点在nodes数组中的下标而非结点本身。如果内存充足，也可以直接在Node中用一个vector保存路径省去顺着fa往回找的麻烦。

```java
public class UVa10603 {

    static class Node implements Comparable<Node> {
        int v[]; 	// 状态，3个杯子中的水量
        int dist; 	// 优化的目标，转移的水量

        public Node() {
            this.v = new int[3];
        }

        public Node(Node other) {
            this.v = new int[3];
            System.arraycopy(other.v, 0, this.v, 0, other.v.length);
            this.dist = other.dist;
        }

        @Override
        public int compareTo(Node o) {
            return Integer.compare(o.dist, this.dist);
        }
    }

    static final int maxn = 200 + 5;

    int vis[][] = new int[maxn][maxn];
    int cap[] = new int[3];
    int ans[] = new int[maxn];

    void update_ans(Node u) {
        for (int i = 0; i < 3; i++) {
            int d = u.v[i];
            if (ans[d] < 0 || u.dist < ans[d]) {
                ans[d] = u.dist;
            }
        }
    }

    void solve(int a, int b, int c, int d) {
        cap[0] = a;
        cap[1] = b;
        cap[2] = c;
        Arrays.fill(ans, -1);

        PriorityQueue<Node> q = new PriorityQueue<>();

        Node start = new Node();
        start.dist = 0;
        start.v[0] = 0;
        start.v[1] = 0;
        start.v[2] = c;
        q.offer(start);

        vis[0][0] = 1;
        while (!q.isEmpty()) {
            Node u = q.poll();
            update_ans(u);
            if (ans[d] >= 0) break;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (i != j) {
                        if (u.v[i] == 0 || u.v[j] == cap[j]) continue;
                        // 从i倒amount的水到j
                        int amount = Math.min(cap[j], u.v[i] + u.v[j]) - u.v[j];
                        Node u2 = new Node(u);
                        u2.dist = u.dist + amount;
                        u2.v[i] -= amount;
                        u2.v[j] += amount;
                        if(vis[u2.v[0]][u2.v[1]] == 0) {
                            vis[u2.v[0]][u2.v[1]] = 1;
                            q.offer(u2);
                        }
                    }
                }
            }
        }
        while (d >= 0) {
            if (ans[d] >= 0) {
                System.out.printf("%d %d\n", ans[d], d);
                return;
            }
            d--;
        }
    }

    public static void main(String[] args) {
        UVa10603 obj = new UVa10603();
        obj.solve(1,3,6,4);
    }
}
```



### 单调队列

单调队列是指队列里的元素满足单调性（单调递增或单调递减），常用来解决某个范围内的最小值或最大值这类问题。

举个例子：有  7 6 8 12 9 10 3 七个数字，现在要找出范围(i-4, i) 的最小值。那么就可以这样模拟一遍。
先初始化 { INF } （表示i=0时的值）
i=1 → { INF } （表示i=1,时，在其范围内最小的值为INF）→ 7进队 { 7 } ；
i=2 → { 7 }（表示i=2,时，在其范围内最小的值为7）→ 6比7小，7出，6进 { 6 }；
i=3 → { 6 } （表示i=3,时，在其范围内最小的值为6）→  8比6大，8进  { 6, 8 }；
i=4 → { 6, 8 }（表示i=4,时，在其范围内最小的值为6）→ 12比8大，12进 { 6, 8 , 12 };
i=5 → { 6, 8 , 12 }（表示i=4,时，在其范围内最小的值为6）→ 9比12小，12出，9比8大，9进 { 6，8,  9 }；
i=6 → { 6，8,  9 } 但是 单调队列中元素6的下标是2，不在（2, 6],中，故6出，这就是单调队列的精髓了，故单调队列为{ 8,9 } → 10比9大，10进，最终单调队列为{ 8，9, 10 } ;
i=7 → { 8，9, 10}（表示i=6,时，在其范围内最小的值为8）→ 3比单调队列为 { 8，9, 10 } 的任意值都小，故全出，最终集合为 { 3 }。

 

**应用**

一个长度为n的整数序列，从中找出一段长度不超过m的连续子序列，使得整个序列的和最大。

例如：  1, -3, 5, 1, -2, 3
当m=4时，sum =  5+1-2+3 = 7
当m=2或m=3时，sum = 5+1 = 6

这题可以用dp来解，此处用单调队列来解。先把序列的前i项和加起来并存到一个数组sum\[]上，那么任意连续的子序列和就为sum\[i] - sum\[j] (i>j &&  j>i-m)。

```java
 public class MaxSumOfLimitedLenSubArray {

    // 借助单调队列
    public static int solve(int[] nums, int n, int k) {
        int[] sum = new int[n + 1];        // 下标从1开始
        sum[0] = 0;
        for (int i = 1; i <= n; i++) {
            sum[i] = sum[i - 1] + nums[i]; /// 求前缀和
        }

        Deque<Integer> queue = new LinkedList<>(); // queue保存下标
        int max = sum[1];
        queue.offer(1);

        for (int i = 2; i <= n; i++) {
            while (!queue.isEmpty() && i - queue.peekFirst() > k) { // 不在[i-k, i]范围内
                queue.pollFirst();
            }
            // 队列的队首是在[i-k, i]范围内sum[j]最小的
            max = Math.max(max, sum[i] - sum[queue.peekFirst()]);

             // 更新单调队列，比sum[i]大的值都去掉，即要保持队列单调递增
            while (!queue.isEmpty() && sum[i] < sum[queue.peekLast()]) { 
                queue.pollLast();
            }
            queue.offer(i); ///最后将下标i入队
        }

        return max;
    }


    public static void main(String[] args) {
        int[] nums = new int[]{0, 1, -3, 5, 1, -2, 3};
        System.out.println(solve(nums, 6, 4));
    }
}
```













### 中位数

【例题】**货仓选址**
在一条数轴上有M家商店，它们的坐标分别为A[1]~A[N]。现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

把A[1]\~A[N]排序，设货仓建在坐标处，X左侧的商店有P家，右侧的商店有Q家。若P<Q，则每把货仓的选址向右移动1单位距离，距离之和就会变小Q-P。同理，若P>Q，则货仓的选址向左移动会使距离之和变小。当P=Q时为最优解。因此货仓应该建在中位数处，即把A排序后，当N为奇数时，货仓建在A\[(N+1)/2]处最优；当N为偶数时，货仓建在A[N/2]~A[N/2+1]之间的任何位置都是最优解。



###  进出栈序列问题
给定1~N这N个整数和一个无限大的栈，每个数都要进栈并出栈一次。如果进栈的顺序为1,2,…,N，那么可能的出栈序列有多少种?

方法一：搜索(枚举/递归)，O(2^N)
一个很直观的想法是，面对任何一个状态我们只有两种选择：
1.把下一个数进栈。
2.把当前栈顶的数出栈(如果栈非空)
我们可以枚举每一步如何选择，用递归实现这个规模为O(2^N)的枚举，这样就得到了所有可能的出栈序列方案。



方法二：递推，O(N^2)

设$S_{N}$表示进栈顺序为1,2,…N时可能的出栈序列总数。根据递推的理论，我们需要想办法把问题分解成若干个类似的子问题
考虑“1”这个数排在最终出栈序列中的位置，如果最后“1”这个数排在第k个，那么整个序列的进出栈过程就是
1.整数 1 入栈。
2.整数 2~k 化这 kー1 个数按某种顺序进出栈。
3.整数 1 出栈，排在第 k 个。
4.整数 k+1~N 这 N-k 个数按某种顺序进出栈。
于是整个问题就被“1”这个数划分成了“kー1个数进出栈和“N一k个数进出栈”这两个子问题，得到递推公式：

$$S_N=\sum_{K=1}^NS_{K-1}*S_{N-K}$$



方法三：动态规划

在任何一个时刻，我们实际上只关心有多少个数尚未入栈、有多少个数还在栈里，并做出一步合法的操作，并不关心这些数具体是哪些。因此，我们可以用 F[i, j] 表示有 i 个数尚未进栈，目前有 j 个数在栈里，已经有 n-i-j 个数出栈时的方案总数。

在最终状态下，即所有数已经出栈时，顺序已经确定，所以边界为：F[0,0]=1。

我们需要求出初始状态下，即所有数尚未进栈时，可以到达上述边界的方案总数，所以目标为：F[N,0]。

每一步的两种决策分别是“把一个数进栈”和“把栈项的数出栈”，所以有公式:

$$F[i,j]=F[i-1,j+1]+F[i,j-1]$$



方法四：数学，O(N)

该问题等价于求第N项 Catalan数，即 $C_{2N}^{N} / (N-1)$





### 后缀表达式



**后缀表达式求值**

1. 建立一个用于存数字的栈，逐一扫描该后缀表达式中的元素。
   1) 如果遇到一个数，则把该数入栈。
   2) 如果遇到运算符，就取出栈顶的两个数进行计算，把结果入栈
2. 扫描完成后，栈中恰好剩下一个数，就是该后缀表达式的值。



**中缀表达式转后缀表达式**

1. 建立一个用于存运算符的栈，逐一扫描中缀表达式中的元素。
   	(1) 如果遇到一个数，输出该数。
   	(2) 如果遇到左括号，把左括号入栈
   	(3) 如果遇到右括号，不断取出栈顶并输出，直到栈顶为左括号，然后把左括号出栈
   	(4) 如果遇到运算符，只要栈顶符号的优先级不低于新符号，就不断取出栈顶并输出，最后把新符号进栈。优先级为乘除>加减>左括号。
2. 依次取出并输出栈中的所有剩余符号，最终输出的序列就是一个与原中缀表达式等价的后缀表达式。





### 社团主席选举

随着又一届学生的毕业，社团主席换届选举即将进行。一共有n个投票者和m个候选人，小易知道每一个投票者的投票对象。但是，如果小易给某个投票者一些糖果，那么这个投票者就会改变他的意向，小易让他投给谁，他就会投给谁。由于小易特别看好这些候选人中的某一个大神，这个人的编号是1，所以小易希望能尽自己的微薄之力让他当选主席，但是小易的糖果数量有限，所以请你帮他计算，最少需要花多少糖果让1号候选人当选。某个候选人可以当选的条件是他获得的票数比其他任何候选者都多。

**输入描述**

第一行两个整数n和m，表示投票者的个数和候选人的个数。 接下来n行，每一行两个整数x和y，x表示这个投票者的投票对象，y表示需要花多少个糖果让这个人改变意向。 满足1 <= n, m <= 3000，1 <= x <= m，1 <= y <= 109。

**样例输入**
1 2
1 20
**样例输出**
0



```java
public class Main {

    static class Vote {
        public int to;
        public int count;
        public Vote(int to, int count) {
            this.to = to;
            this.count = count;
        }
    }

    static class Solution {
        private int[] ballot; // 初始投票
        private List<Vote> votes; // 非投票给1号的其他投票
        private int res = Integer.MAX_VALUE;

        public Solution(int[] ballot) {
            this.ballot = ballot;
            this.votes = new ArrayList<>();
        }

        public void addVote(int to, int count) {
            votes.add(new Vote(to, count));
        }

        public void addBallot(int to) {
            ballot[to] ++;
        }

        public boolean satisfy(int[] ballot) { // 是否满足
            for (int i = 2; i < ballot.length; i++) {
                if (ballot[i] >= ballot[1]) {
                    return false;
                }
            }
            return true;
        }
		
        // 暴力搜索，枚举所有种可能
        // 但是只通过了部分测试case todo
        public int solve() {
            int[] copy = new int[ballot.length];
            for (int i = 0; i < (1 << votes.size()); i++) {
                System.arraycopy(ballot, 0, copy, 0, ballot.length);
                int count = 0;
                for (int j = 0; j < votes.size(); j++) {
                    if ((i & (1 << j)) > 0) {
                        Vote vote = votes.get(j);
                        copy[1]++;
                        copy[vote.to]--;
                        count += vote.count;
                    }
                }
                if (satisfy(copy)) {
                    res = Math.min(res, count);
                }
            }

            return res;
        }
    }


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();

        Solution solution = new Solution(new int[m+1]);

        for (int i = 0; i < n; i++) {
            int to = scanner.nextInt();
            int count = scanner.nextInt();

            solution.addBallot(to);
            if(to != 1) {
                solution.addVote(to, count);
            }
        }

        System.out.println(solution.solve());

    }

}
```

参考 [网易历届笔试题（9）](https://blog.csdn.net/haut_ykc/article/details/116212548)













## 二分法



**二分查找基本算法**

```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) { // 注意
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    
    return -1;
}
```



**寻找左侧边界的二分搜索**

```java
int leftBound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意

    while (left < right) {  // 注意搜索区间决定了这里是<, 而不是 <=, 即左闭右开
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}
```

函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，如果不存在target要返回-1, 则要加上

```
while (left < right) {
    //...
}
// target 比所有数都大
if (left == nums.length) return -1;
// 类似之前算法的处理方式
return nums[left] == target ? left : -1;
```



**寻找右侧边界的二分查找**

```
int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;

    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return left - 1; // 注意
}
```





考虑“求满足某个条件C(x)的最小的x”这一问题。对于任意满足C(x)的x，如果所有的x'≥x也满足C(x)的话，我们就可以用二分搜索来求得最小的x。首先我们将区间的左端点初始化为不满足C(x)的值，右端点初始化为满足C(x)的值。然后每次取中点mid=(lb+ub)/2，判断C(mid)是否满足并缩小范围，直到(lb, ub]足够小了为止。最后ub就是要求的最小值。最大化的问题也可以用同样的方法求解。



### cable master

有N条绳子，它们的长度分别为Li。如果从它们中切割出K条长度相同的绳子的话，这K条绳子每条最长能有多长？答案保留到小数点后2位。

这个问题用二分搜索可以非常容易地求得答案。让我们套用二分搜索的模型试着解决这个问题。令条件

C(x) := 可以得到K条长度为x的绳子

则问题变成了求满足C(x)条件的最大的x。在区间初始化时，只需使用充分大的数INF>Max(Li)作为上界即可:

lb = 0, ub = INF

现在的问题是是否可以高效地判断C(x)。由于长度为L的绳子最多可以切出floor(L/x)段长度为x绳子，因此

C(x) := (floor(Li/x) 的总和是否大于等于K

```java
public class CableMaster {

    public void  solve(double[] arr, int k) {
        double lb = 0;
        double ub = 0;
        for(double l : arr) {
            ub = Math.max(ub, l);
        }
        ub = ub + 1;


        for(int i=0 ; i<100; i++) {
            double mid = (lb + ub) / 2;
            if(C(arr, mid, k)) {
                lb = mid;
            } else {
                ub = mid;
            }
        }
        // 注意最后的Math.floor
        System.out.printf("%.2f", Math.floor(ub*100) / 100);
    }

    private boolean C(double[] arr, double x, int k) {
        int num = 0;
        for(double l : arr) {
            num += (int)(l/x);
        }
        return num >= k;
    }

}

```





### 最大化平均值

有n个物品的重量和价值分别是wi和vi。从中选出k个物品使得单位重量的价值最大。

一般最先想到的方法可能是把物品按照单位价值进行排序，从大到小贪心地进行选取。但是这种解法是不对的。

对于这个问题使用二分搜索法可以很好地解决。我们定义条件

C(x) := 可以选择使得单位重量的价值不小于x

因此，原问题就变成了求满足C(x)的最大的x。那么怎么判断C(x)是否可行呢?假设我们选了某个物品的集合S，那么判断条件就变成是否存在S满足

$$\sum_{i \in S} v_{i} / \sum_{i \in S} w_{i} >= x $$

把这个不等式进行变形就得到

$$\sum_{i \in S}\left(v_{i}-x \times w_{i}\right) \geqslant 0$$

因此,可以对$\left(v_{i}-x \times w_{i}\right)$的值进行排序贪心地进行选取。因此就变成了

C(x) = ( $\left(v_{i}-x \times w_{i}\right)$ 从大到小排列中的前k个的和不小于0 ) 

```java
public class MaximizeAverage {

    public void solve(int[] w, int[] v, int k) {
        double lb = 0;
        double ub = 0;
        for (int i = 0; i < w.length; i++) {
            ub = Math.max(ub, v[i] / w[i]);
        }

        for (int i = 0; i < 100; i++) {
            double mid = (lb + ub) / 2;
            if (C(w, v, k, mid)) {
                lb = mid;
            } else {
                ub = mid;
            }
        }

        System.out.printf("%.2f",  ub*100 / 100);
    }

    private boolean C(int[] w, int[] v, int k, double x) {
        double[] y = new double[w.length];
        for (int i = 0; i < w.length; i++) {
            y[i] = v[i] - x * w[i];
        }
        Arrays.sort(y);

        double sum = 0;
        for (int i = 0; i < k; i++) {
            sum += y[y.length-i-1];
        }
        return sum >= 0;
    }

     
}
```





### 两个有序数组的中位数

给定两个大小为m和n的有序数组nums1和nums2，请找出这两个有序数组的中位数，并且要求算法的时间复杂度为O(log(m + n)).



**分析**

首先看下如何求出任意个数有序数组的中位数：

| 情况                                      | 求解思路                                                     |
| ----------------------------------------- | ------------------------------------------------------------ |
| 当数组个数为奇数时<br />nums=[1,2,3,4,5]  | (nums[(nums.length+1)/2-1] + nums[(nums.length+2)/2-1]) / 2.0<br/>=(nums[(5+1)/2-1]+nums[(5+2)/2-1]) / 2.0<br/>=(nums[2]+nums[2]) / 2.0 = 3 |
| 当数组个数为偶数时<br/>nums=[1,2,3,4,5,6] | (nums[(nums.length+1)/2-1] + nums[(nums.length+2)/2-1]) / 2.0<br/>=(nums[(6+1)/2-1]+nums[(6+2)/2-1]) / 2.0<br/>=(nums[2]+nums[3]) / 2.0 = 3.5 |

对于两个有序数组来说，我们只要找出第(m+n+1)/2大的数和第(m+n+2)/2大的数，然后求平均数即可。那么问题就可归结为在两个有序数组中找第k大的数。由时间限制的要求容易想到采用二分法。 

在查找时，我们还需要考虑一些特殊情况：(1) 当某个数组查找的起始位置大于等于该数组长度时，说明这个数组中的所有数已经被淘汰，则只需要在另一个数组找查找即可。(2)如果k=1时，即需要查找第一个数，则找到两个数组起始位置中最小的那个即可。处理完特殊情况后，我们来分析一般情况。这里所说的二分是指对数组的大小进行二分还是指对k进行二分。**以前对一维数组进行二分查找时，一般都是对数组大小进行二分，而这里需要对k进行二分。**意思是，我们需要在两个数组查找第k/2大的数，由于这两个数组的长度不定，有可能存在有一个数组中没有第k/2大的数，如果没有则赋值为整型最大值。

```java

class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int l = (m + n + 1) / 2;
        int r = (m + n + 2) / 2;
        return (getKth(nums1, 0, nums2, 0, l) + getKth(nums1, 0, nums2, 0, r)) / 2.0;
    }
 
    // 在两个有序数组中二分查找第k大元素
    private int getKth(int[] nums1, int start1, int[] nums2, int start2, int k){
        // 特殊情况(1)
        if(start1 > nums1.length-1) return nums2[start2 + k - 1];
        if(start2 > nums2.length-1) return nums1[start1 + k - 1];
        // 特征情况(2)
        if(k == 1) return Math.min(nums1[start1], nums2[start2]);
 
        // 分别在两个数组中查找第k/2个元素，若存在（即数组没有越界），标记为找到的值；
        // 若不存在，标记为整数最大值
        int nums1Mid = start1 + k/2 - 1 < nums1.length ? 
                       nums1[start1 + k/2 - 1] : Integer.MAX_VALUE;
        int nums2Mid = start2 + k/2 - 1 < nums2.length ?
                       nums2[start2 + k/2 - 1] : Integer.MAX_VALUE;
 
        // 确定最终的第k/2个元素，然后递归查找
        if(nums1Mid < nums2Mid)
            return getKth(nums1, start1 + k/2, nums2, start2, k-k/2);
        else
            return getKth(nums1, start1, nums2, start2 + k/2, k-k/2);
    }
}
```





### 贪吃的小Q

小Q的父母要出差N天，走之前给小Q留下了M块巧克力。小Q决定每天吃的巧克力数量不少于前一天吃的一半，但是他又不想在父母回来之前的某一天没有巧克力吃，请问他第一天最多能吃多少块巧克力。

我的解答

```java
public class Main {

    public static int solve(int n, int m) {
        int lo = 1;
        int hi = m;
        int ans = 0;
        while (lo <= hi) {
            int mid = (lo + hi) / 2;
            int sum = sum(n, mid);
            if (sum == m) {
                return mid;
            } else if (sum > m) {
                hi = mid - 1;
                ans = mid - 1;
            } else {
                ans = mid;
                lo = mid + 1;
            }
        }
        return ans;
    }

    private static int sum(int n, int t) {
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += t;
            t = (t + 1) / 2; // 向上取整
        }
        return sum;
    }


    public static void main(String[] args) {
        // 3 7 -> 4
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        System.out.println(solve(n, m));
    }
}
```



### 分贝壳

牛牛和妞妞去海边捡了一大袋美丽的贝壳，千辛万苦地运回家后，牛牛和妞妞打算分掉这些贝壳。

牛牛提出，他和妞妞轮流从还没有分配的贝壳中取一定数量的贝壳，直到贝壳分完为止。分配规则是牛牛每次取剩余贝壳的1/10（向下取整），妞妞每次固定取m个贝壳，妞妞先取。

妞妞想要得到不少于一半的贝壳，又不想太过分，那么她一次最少取多少个贝壳才能得到不少于一半的贝壳呢？



样例输入
10
样例输出
1



**我的解答**

```java
public class Main {
    
    public static int solve(int n) {
        int lo = 1;
        int hi = n;
        while (lo <= hi) {
            int mid = (lo + hi) / 2;
            if (more(n, mid)) { // 分支1
                hi = mid - 1;
            } else {            // 分支2 
                lo = mid + 1;
            }
        }
        // 返回哪个，看跳出循环时的情况，跳出循环时满足lo=hi+1，
        // 不管从分支1和分支2跳出最终取得都是lo
        return lo;
    }

    public static boolean more(int n, int m) {
        int sum1 = 0;
        int sum2 = 0;
        while (n > m) {
            if (n <= m) {
                sum1 += n;
                break;
            }
            sum1 += m;
            int t = (n - m) / 10;
            sum2 += t;
            n = n - m - t;
        }
        return sum1 >= sum2;
    }
}
```







## 分治法



### 最近点对问题

**描述**：给定某点集，求其中点对之间距离的最小值。

**分析**

1) 对各个点根据x坐标排序后，记中间的点为P[n/2]

2) 对中间点两侧的子点集分别求其中的最近点对的距离dl和dr，并记两者的较小者为d

<img src="algorithm/mindis.png" alt="mindis" style="zoom: 67%;" />

3) 在上一步之后，可以得到最短距离的上界为d. 现在需要考虑各来自左右两边点构成的点对间距。考虑有一条通过中间点的垂直线，那么只需要找出x左边距离该垂直线在d之后的点。把这些点组成的集合记为strip[]

<img src="algorithm/closepair.png" alt="closepair" style="zoom:67%;" />

4) strip[]中的点根据y坐标排序

5) 求出strip[]中点对之间的最短距离。这似乎看上去需要O(n^2)的时间，但是可以证明每个点只需要和其后（根据y坐标排序后）最多7各点作比较，因此实际上是O(N)的时间。 [证明参考](https://www.cs.ubc.ca/~liorma/cpsc320/files/closest-points.pdf)

6) 最后取d和strip[]中最短距离的较小值即可。



```java
public class ClosestPair {
    static class Point {
        int x, y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    int compareX(Point p1, Point p2) {
        return (p1.x - p2.x);
    }

    int compareY(Point p1, Point p2) {
        return (p1.y - p2.y);
    }

    double dist(Point p1, Point p2) {
        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +
                (p1.y - p2.y) * (p1.y - p2.y)
        );
    }

    // 暴力求解
    double bruteForce(Point P[], int left, int right) {
        double min = Double.MAX_VALUE;
        for (int i = left; i < right; ++i)
            for (int j = i + 1; j < right; ++j)
                if (dist(P[i], P[j]) < min)
                    min = dist(P[i], P[j]);
        return min;
    }

    // A utility function to find the
    // distance beween the closest points of
    // strip of given size. All points in
    // strip[] are sorted accordint to
    // y coordinate. They all have an upper
    // bound on minimum distance as d.
    // Note that this method seems to be
    // a O(n^2) method, but it's a O(n)
    // method as the inner loop runs at most 6 times
    double stripClosest(Point strip[], int size, double d) {

        double min = d; // Initialize the minimum distance as d

        Arrays.sort(strip, Comparator.comparingInt(p -> p.y));

        // Pick all points one by one and try the next points till the difference
        // between y coordinates is smaller than d.
        // This is a proven fact that this loop runs at most 6 times
        for (int i = 0; i < size; ++i)
            for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < min; ++j)
                if (dist(strip[i], strip[j]) < min)
                    min = dist(strip[i], strip[j]);

        return min;
    }


    // A recursive function to find the
    // smallest distance. The array P contains
    // all points sorted according to x coordinate
    double closestUtil(Point P[], int left, int right) {
        // If there are 2 or 3 points, then use brute force
        int n = right - left;
        if (n <= 3)
            return bruteForce(P, left, right);

        // Find the middle point
        int mid = (left + right) / 2;
        Point midPoint = P[mid];

        // Consider the vertical line passing
        // through the middle point calculate
        // the smallest distance dl on left
        // of middle point and dr on right side
        double dl = closestUtil(P, left, mid);
        double dr = closestUtil(P, mid, right);

        // Find the smaller of two distances
        double d = Math.min(dl, dr);

        // Build an array strip[] that contains
        // points close (closer than d)
        // to the line passing through the middle point
        Point strip[] = new Point[n];
        int j = 0;
        for (int i = 0; i < n; i++) {
            if (Math.abs(P[i].x - midPoint.x) < d)
                strip[j++] = P[i];
        }
        Point strip_[] = new Point[j];
        System.arraycopy(strip, 0, strip_, 0, j);


        // Find the closest points in strip.
        // Return the minimum of d and closest
        // distance is strip[]
        return Math.min(d, stripClosest(strip_, j, d));
    }


    double closest(Point[] points) {
        Arrays.sort(points, Comparator.comparingInt(p -> p.x));
        return closestUtil(points, 0, points.length);
    }

    public static void main(String[] args) {
        Point P[] = new Point[6];
        P[0] = new Point(2, 3);
        P[1] = new Point(12, 30);
        P[2] = new Point(40, 50);
        P[3] = new Point(5, 1);
        P[4] = new Point(12, 10);
        P[5] = new Point(3, 4);

        System.out.println("The smallest distance is " + new ClosestPair().closest(P));

    }
}

```





## 贪心算法



### 最强团队

有一个阵营，里面有n 个小队(1<=n<=100)，每个小队都有他们的能力值ai(0<=i<n)。现在有一个紧急情况，需要从这些小队中选出连续的几个小队，组成一个最强的团队。最强的团队的定义为这个团队的所有小队的平均能力值最高。如果有多个最强团队，则选包含小队最多的一个。



**分析**：首先由能力值最大的小队单一组成的团队肯定是“最强”，因此不用考虑其他情况了。而再要包含小队最多，就是要求连续的最大值有几个。



### 一的个数 TODO

在给定区间[l, r]内的所有数中，二进制表示下“1”的个数最多的一个数是多少，如果有多个相同的，输出所有符合条件的数中最小的一个数。
输入一个整数l，和一个整数r。(1<=l<=r<=10^9)
输出一个数字表示[l, r]内二进制下“1”的个数最多的数。如果有多个，输出符合条件的数中最小的。

**分析**：

所求数字可分为两部分，高位部分和低位部分，高位部分的值等于l, r高位相等的部分，在区间[l,r]中的所有数的高位部分都应该与其相等，即

`high = r & (-1<<count) `，其中 count 为` l^r` 的二进制的位数。

低位的部分计算过程如下：

如果 r-high 的值的二进制全为1，则低位部分为 r-high。如果不全为1，则低位部分为`( 1<<(count-1) ) - 1`





### 钱庄

钱庄每天能够收到很多散钱，第i个散钱的值为2\^wi。为了便于管理，钱庄每天都会向中央银行申请兑换钱币，假设钱庄有一些散钱使得2\^k1+2\^k2+...+2\^km=2\^x（x 为非负整数），那么就可以将这些散钱兑换成一个大钱币，问在钱庄收到的这些散钱最终最少能变成几个钱币？

**分析**：

遍历一遍m 找出m 中的最大数max，定义一个数组arr[max+2]，用于统计出m 数组中，每个数字出现的次数，即arr[m[i]]++（m 中的元素为下标，arr 数组中保存出现的次数）;
然后遍历arr 数组(0<=i<=max)，如果当前元素arr[i]==0，那就下一个；如果不为0，令arr[i+1]+=arr[i]/2（每两个arr[i] 就能凑一个arr[i+1]）。如果arr[i] 为奇数，那说明剩余一个arr[i]，这最后也就剩下了，所以ans++；
遍历完后 if(arr[max+1] !=0 ) ans++; 然后return ans;



### 过吊桥

同学A准备去爬山，当爬到了半山腰时，发现了一个吊桥。这个吊桥总共由 n 块标号为 1~n 的木板组成，由于年久失修，这些木板有些已经快要坏掉了，每块木板都有一个值ai 表示第i 块木板还有ai 分钟就要坏掉了，即在第ai+1 分钟将无法站上这块木板。
该同学过吊桥时一步只能走一块或两块木板，但是他想在吊桥的这边多玩一会。请问他在吊桥这边最多可以玩多长时间（可以认为该同学能在一分钟内通过吊桥，即过桥时间忽略不计）？特殊的，如果第一块或者最后一块木板坏掉的话吊桥就直接无法通过了。



**分析**：

根据题意，要知道同学A还能在桥的一头逗留的时间，需要先求出什么时候有连续的两块木板坏掉，或者第一块或者最后一块木板坏掉。

首先将数组存入 Map 中，以数字为 key，索引的位置为 value（因为数组中有可能会有相同的数字，而value 值要存储所有数字的索引，所以索引只能以List 的形式存在 value 中）。这样存储以后，只要知道数组中的数字，就能快速找到其索引。
接下来对数组进行升序排序，再创建一个大小相同的数组 status 用来记录木板的状态，然后遍历数组。
每遍历一个数，就通过 HashMap 查找其索引，在status 数组中根据这个索引将这个木板的状态置为-1，代表木板坏掉了。然后判断是否符合不能通过桥的条件，若符合条件，此时在数组遍历的数即为可以逗留的时间。若不符合条件，则继续遍历数组，重复上述步骤，直到符合条件为止。





### Tairitsu and Dynamic Objects

Hikari 和 Tairitsu 面前有n 个物品，这些物品编号为1,2,...,n。每个物品有两个属性。第 i 个物品的两个属性分别为ai, bi 。初始 n 个物品均可被选取。Hikari 与 Tairitsu 会轮流选取当前可选取的物品中的一个，并把它拿走，这个物品之后不可被选取。第一轮 Hikari 先选取。设 Hikari 选取的物品编号的集合为H ，Tairitsu 选取的物品编号的集合为T 。所有物品均被选取完之后，Hikari 得分为Σ ai(i ∈ H) ；而 Tairitsu 得分为Σ bi(i ∈ T) 。

Hikari 和 Tairitsu 都希望自己的得分比对方大，你需要求出双方都使用最优策略的情况下，双方各会获得多少分。
注意：若对于某个人来说，剩余的物品中有多个对两人分数大小关系影响相同的物品，那么他会优先选择bi 最大的那个。



**分析**：

Hikari 和 Tairitsu 每次会优先选择 ai+bi 的值最大的物品（即可以使得自己得分最多且阻止对方多得分），当物品的 ai+bi 值都相等时，选择bi 大的那个。



### Codancer的炸弹引爆 TODO



Codancer 终于抵达了恶龙的城堡。现在他在城堡周围摆放了n 枚电力炸弹，每个电力炸弹有两种属性m 和p，只有已经引爆了m 枚电力炸弹或者Codancer 直接花费p 的电力，第i 枚炸弹才会被引爆，现在Codancer 想使用最少的电力引爆所有的炸弹，请计算最少需要多少电力？

第一行是一个正整数n，代表有n 枚电力炸弹。接下来输入n 行，每行两个正整数m 和p，代表炸弹的属性(1<=n<200000,1<=p<=100,1<=m<=n)

输出最少花费多少的电力。



示例1
输入：
3
[[1,5],[2,10],[2,8]]

输出：
8

说明：花费8 电力引爆第3 枚炸弹，那么第1 枚就会被自动引爆，那么第2 枚也会被自动引爆。



### 学习小组

在一个课堂上，有 n 个学生 (1<=n<=3e\^5)，每个学生都有他们自己的学分$a_{i}$($a_{i} >= a_{i-1}$)，现在老师想将他们分为 m 个小组 (1<=m<=n)，为了方便交流，所有的小组都是由相邻的学生组成，现在老师想让每个小组的学分差值尽量小 ( 最大值减去最小值 )，请你帮助老师来分一下组，输出最后的每个小组的最小的差值的总和。

第一行和第二行输入两个数 n、m 表示有 n 个学生要分成 m 个小组，再输入 n个数，表示每个学生的学分。
输出一个数字，表示最后分出的 m 个小组的最小的差值的总和。

**分析**：

因为题目中说了 ai 是一个非递减的数列，所以可以推导出一个式子。比如我们将一个数组分成 3 组，假设为[$a_{1}$, $a_{i}$], [$a_{i+1}$, $a_{j}$], [$a_{j+1}$, $a_{n}$]这三组，那么所要求的值就是 ($a_{i}$ - $a_{1}$) + ($a_{j}$- $a_{i+1}$) + ($a_{n}$ - $a_{j+1}$)，也就是 $a_{n} - a_{1} - (a_{j+1} - a{j}) - (a_{i+1} - a{i})$. 从这个式子可以看出要求总的差值最小，就需要用 $(a_{n}-a{i})$ 再ji减去最大的(m-1)个相邻的差值。而$(a_{i+1} - a{i})$ 显然是一个差分性质，所以我们对于原数列求一个差分数组出来，然后对差分数组进行排序，贪心的去减去前 m-1 个最大的就好了。

```java
public class Solution {
    public int solution(int n, int m, int[] nums) {
        int[] sub = new int[n-1];
        for(int i = 0; i < (n-1); i++){
           sub[i] = nums[i+1] - nums[i];
        }
        Arrays.sort(sub);
        int ans = nums[n-1] - nums[0];
        for(int i = 0;i< (m-1) ;i++){
            ans = ans - sub[n-2-i];
        }
        return ans;
    }
}
```









## 动态规划



[TODO]

https://oi-wiki.org/dp/



### 移动射击

你正在数轴上跟小精灵对战。你拥有一个十分强力的技能称为移动射击，但是这个技能有一个缺点是在你发动之后只能改变一次方向。

你可以认为你的位置在数字 0 的位置上，在数轴的正方向上有 n 只精灵，负方向上有 m 只精灵。移动射击总共可以造成 w 点伤害。每个精灵都有自己的血量，当血量降为 0 时死亡。

在最开始时你可以选择向正方向或负方向释放移动射击，并且可以在任意时刻改变技能的方向。请问你最多可以击杀多少只小精灵 ?(n，m，w 以及精灵的血量均在[1, 100000] 范围内 )

输入内容为五个，前三个为三个数字 ：正方向上的精灵个数 n、负方向上的精灵个数 m, 移动射击可以造成的伤害 w；第四个是一个长度为 n 的数组 a，表示正方向上的 n 个精灵的血量；第五个是一个长度为 m 的数组 b，表示负方向上的 m 个精灵的血量。

输出一个数字，表示最多能够击杀的精灵数量。



**大致思路**： 首先理解题意，题目说的“发动之后只能改变一次方向”是干扰你的，因为即使你在中间过程中左右摆，但宏观上还是最多改变了一次方向。如果说：我先杀左边一个，然后转头杀右边一个，再转头杀左边三个，又回头杀右边 1 个，看起来是不是改变了三次方向，其实呢，相当于我先杀左边四个，再回头杀右边两个，效果是一样的。因此你想这个问题的时候，可以忽略这个限制。

**具体过程**： 先遍历数组 a，a[i] 表示数组 a 前 i 个数的和，当 a[i]>=w 的时候，记住此时的位置 index_a=i，退出循环，退出后加上这句 if(i==n||a[i]>w) index_a–-;因为 index_a 指向的是刚好不超过 w 的位置，而且不能越界。
对 b 数组也是如此，然后开始从 index_a 往后一步一步走 ；走一步，看看 b 数组的情况，k 为 b 数组的下标，初始 k=0;

```java
while(k<m && a[i]+b[k]<=w) k++;
```

然后和当前的ans作比较

```java
ans=Math.max(ans,i+k+1);
```



```java
public class Solution075 {


    public static int solution(int n, int m, int w, int[] a, int[] b) {
        int index_a = 0;
        int index_b = 0;
        int sum_a = 0;
        int sum_b = 0;
        for(int i = 0;i<a.length;i++){
            sum_a = sum_a + a[i];
            index_a = i;
            if(sum_a > w){
                index_a = i - 1;
                sum_a = sum_a - a[i];
                break;
            }
        }
        
        int ans1 = 0;
        for(int ina = index_a;ina >= 0;sum_a = sum_a - a[ina],ina--){
            int k = 0;
            int sum = sum_a;
            while(k<m && sum+b[k]<=w){ // 向左边扩展
                sum = sum +b[k];
                k++;
            }
            ans1 = Math.max(ans1,ina+k+1);
        }
        
        
        for(int i = 0;i<b.length;i++){
            sum_b = sum_b + b[i];
            index_b = i;
            if(sum_b > w){
                index_b = i - 1;
                sum_b = sum_b - b[i];
                break;
            }
        }
        
        int ans2 = 0;
        for(int inb = index_b;inb >= 0;sum_b = sum_b - b[inb],inb--){
            int k = 0;
            int sum = sum_b;
            while(k<n && sum+a[k]<=w){
                sum = sum +a[k];
                k++;
            }
            ans2 = Math.max(ans2,inb+k+1);
        }
        
        int ans = 0;
        ans = Math.max(ans1,ans2);
        return ans;
    }

    public static void main(String[] args){
        int[] a = {4,3,2,1};
        int[] b = {1,2,3};
        System.out.println(solution(4,3,10,a,b));
    }
}
```







### 硬币找零问题一

假设有 k 种面值的硬币，面值分别为 c1, c2 ... ck。给定一个总金额 n，问最少需要几枚硬币凑出这个金额，如果不可能凑出，则返回-1。

这个问题的递推公式比较容易得出
$$
f(n)=\left\{\begin{array}{ll} 0  \qquad ,  当 \   n=0 \\
1+\min \left\{f\left(n-c_{i}\right) | i \in[1, k]\right\}
\end{array}\right.
$$


递归写法

```c++
int coinChange(vector<int>& coins, int amount) {
    if (amount == 0) return 0;
    int ans = INT_MAX;
    for (int coin : coins) {
        // 金额不可达
        if (amount - coin < 0) continue;
        int subProb = coinChange(coins, amount - coin);
        // 子问题无解
        if (subProb == -1) continue;
        ans = min(ans, subProb + 1);
    }
    return ans == INT_MAX ? -1 : ans;
}
```

时间复杂度分析：子问题总数 x 每个子问题的时间。子问题总数为递归树节点个数，这是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k*n^k)，指数级别。



动态规划

```c++
int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0;
    for (int i = 0; i < dp.size(); i++) {
        // 内层 for 在求所有子问题 + 1 的最小值
        for (int coin : coins) {
            if (i - coin < 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```







### 硬币找零问题二

http://www.acmerblog.com/dp6-coin-change-4973.html

假设有m种面值不同的硬币，面值存于数组S ={S1，S2，… Sm}中，现在用这些硬币来找钱，各种硬币的使用个数不限。 求对于给定的钱数N，最多有几种不同的找钱方式。硬币的顺序并不重要。

 

要算总的解决方案数，可以把所有的一整套解决方案在两组，要么包含某个元素，要么不包含。 

1）解决方案不包含 第m种硬币（或Sm）。

2）解决方案包含至少一个 第m种硬币。

用计数(S[] , M, N)表示解的数目，则它可以表示为计数 (S[], M-1, N)和计数(S[], M, N-Sm)的和



```java
// 递归
public class Main {

    public static void main(String[] args) throws Exception{
        int arr[] = {1, 2, 3};
        int m = arr.length;
        int n = 4;
        System.out.println(count(arr, m, n));
    }

    public static int count(int S[], int m, int n){
        // 如果n为0，就找到了一个方法
        if (n == 0)
            return 1;
        if (n < 0)
            return 0;

        // 没有硬币可用了，也返回0
        if (m <=0 )
            return 0;

        //递归
        return count(S, m - 1, n) + count(S, m, n-S[m-1]);
    }
}

```



```java
// 动态规划
public static int count_dp(int S[], int m, int n){
    int i, j, x, y;

    // 通过自下而上的方式打表我们需要n+1行
    // 最基本的情况是n=0
    int table[][] = new int[n+1][m];

    // 初始化n=0的情况 (参考上面的递归程序)
    for (i=0; i<m; i++)
        table[0][i] = 1; //n为0的都是1

    for (i = 1; i < n+1; i++){
        for (j = 0; j < m; j++){
            // 包括 S[j] 的方案数
            x = (i-S[j] >= 0) ? table[i - S[j]][j]: 0;

            // 不包括 S[j] 的方案数
            y = (j >= 1)? table[i][j-1]: 0;

            table[i][j] = x + y;
        }
    }
    return table[n][m-1];
}
```





### 划分回文串

http://blog.csdn.net/u013514182/article/details/42615247

给定一个字符串s，将s分割成一些子串，使每个子串都是回文。

返回s符合要求的的最少分割次数。

$flag[i][j]$: $[i,j]$区间子串是否为回文串。$flag[i][j]=(flag[i+1][j-1]\ \&\& \ a[i]==a[j])\ ? \ 1 \ :\ 0$  ;

$dp[i]$: 前i个字符子串最少分成几个回文串。

$dp[i]=min\{dp[j]+1, flag[j+1][i]==1\}$

时间复杂度：$O(n^2)$

 

```java
public static int minCut(String s){
    int len = s.length();
    boolean P[][] = new boolean[len][len];
    int dp[] = new int[len + 1];
    for (int i = 0; i <= len; ++i) {
        dp[i] = len - i - 1;
    }
    for (int i = 0; i < len; ++i) {
        for (int j = 0; j < len; ++j) {
            P[i][j] = false;
        }
    }
    for (int i = len - 1; i >= 0; --i) {
        for (int j = i; j < len; ++j) {
            if (s.charAt(i) == s.charAt(j) && (j - i <= 1 || P[i + 1][j - 1])) {
                P[i][j] = true;
                dp[i] = Math.min(dp[i], dp[j + 1] + 1);
            }
        }
    }
    return dp[0];
}
```







### 最少插入字符

http://www.geeksforgeeks.org/dynamic-programming-set-28-minimum-insertions-to-form-a-palindrome/

https://gist.github.com/sing1ee/a97b21fd50a0ae90e62b

 给定一个字符串str，长度为n，怎么插入最少的字符，使得字符串变为回文呢？



**分析**

 这个题目，递归该如何解呢？插入最少的字符，就是要尽量利用原来的字符，在原字符串str中，尽量利用更多能够匹配的字符。怎么对这个问题进行分解呢？考虑str字符串整体：

1.如果str[0]==str[n-1]，则问题转变为求str[1,n-2]，插入最少字符，得到回文

2.如果str[0]!=str[n-1]，则需要插入一个字符要么和str[0]相同，要么和str[n-1]相同，

如果和str[0]，则转变为str[1,n-1]，插入最少字符，得到回文

如果和str[n-1]，则转变为str[0,n-2]，插入最少字符，得到回文

上面的第2种情况中，需要取两个值最小值。则完成了问题的分解，并且，基本情况也分析完全，则有递归式为：

$fmi(str, l, h) = (str[l] == str[h]) ? fmi(str, l+1, h-1) : (min(fmi(str, i+1, h), fmi(str,l, h-1))+1)$





### 切木棍Cutting a Rod

不同长度的木棍有不同的价值，切割一根木棍使得价值最大化

http://www.geeksforgeeks.org/dynamic-programming-set-13-cutting-a-rod/

Let cutRoad(n) be the required (best possible price) value for a rod of **lenght n**. cutRod(n) can be written as following.

cutRod(n) = max(price[i] + cutRod(n-i-1)) for all i in {0, 1 .. n-1}



比较容易理解的递归方法

```java
public class Main {

    public static void main(String[] args) {
        //长度分别是1   2   3   4   5   6   7   8  
        int arr[] = new int[] {1, 5, 8, 9, 10, 17, 17, 20};
        int size = arr.length
        System.out.println("Maximum Obtainable Value is " + cutRod(arr, size));
    }
    /* Returns the best obtainable price for a rod of length
       n and price[] as prices of different pieces */
    static int cutRod(int price[], int n) {
        if (n <= 0)
            return 0;
        int max_val = Integer.MIN_VALUE;

        // Recursively cut the rod in different pieces and
        // compare different configurations
        for (int i = 0; i<n; i++)
            max_val = Math.max(max_val, price[i] + cutRod(price, n-i-1));

        return max_val;
    }
}
```







### 字符串交错组成

对于三个字符串A，B，C。我们称C由A和B交错组成，当且仅当C包含且仅包含A，B中所有字符，且对应的顺序不改变。请编写一个高效算法，判断C串是否由A和B交错组成。



**分析**

构造一个(M+1)*(N+1)的矩阵dp：

1. dp[0] [0]=true. C为空时可以由A和B的空字符串组成

2. dp[i] [0] 表示C[0…i-1]能否由A[0…..i-1]组成，若可以则dp[i] [0]=true; 反之则为false

3. dp[0] [j] 表示C[0…j-1]能否由B[0…..j-1]组成，若可以则dp[0] [j]=true; 反之则为false

4. 其他位置(i,j) dp[i] [j]的值：

   dp[i-1] [j]表示C[i+j-2]能否被A[0…i-2]和B[0…j-1]交错组成，若可以，以及A[i-1]等于C[i+j-1], 则dp[i] [j]=true，反之则为false; 

   dp[i] [j-1]表示C[i+j-2]能否被A[0…i-1]和B[0…j-2]交错组成，若可以，以及B[j-1]等于C[i+j-1], 则dp[i] [j]=true，反之则为false; 

   若前两种情况都不满足，则dp[i] [j]=false

```java
public class StringMixture {

    public boolean solve(String A, String B, String C) {
        int n = A.length();
        int m = B.length();
        int v = C.length();
        if (n + m != v) {
            return false;
        }
        boolean[][] dp = new boolean[n + 1][m + 1];
        dp[0][0] = true;
        // 只由A组成
        for (int i = 1; i < n; i++) {
            if (A.charAt(i - 1) != C.charAt(i - 1)) {
                break;
            } else {
                dp[i][0] = true;
            }
        }
        // 只由B组成
        for (int j = 1; j < m; j++) {
            if (B.charAt(j - 1) != C.charAt(j - 1)) {
                break;
            } else {
                dp[0][j] = true;
            }
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if ((dp[i - 1][j] && A.charAt(i - 1)  == C.charAt(i + j - 1) ) ||
                        (dp[i][j - 1] && B.charAt(j - 1) == C.charAt(i + j - 1))) {
                    dp[i][j] = true;
                } else {
                    dp[i][j] = false;
                }
            }
        }

        return dp[n][m];
    }

}

```



### 最大连续子序列乘积

输入n个元素组成的序列S，你需要找出一个乘积最大的连续子序列，如果这个最大乘积不是正数，则输出0。



**分析**

考虑到乘积子序列中有正有负也还可能有0，我们可以把问题简化成这样：数组中找一个子序列，使得它的乘积最大；同时找一个子序列，使得它的乘积最小（负数的情况）。因为虽然我们只要一个最大积，但由于负数的存在，我们同时找这两个乘积做起来反而方便。也就是说，不但记录最大乘积，也要记录最小乘积



假设数组为a[]，直接利用动态规划来求解，考虑到可能存在负数的情况，我们用maxend来表示以a[i]结尾的最大连续子串的乘积值，用minend表示以a[i]结尾的最小的子串的乘积值，那么状态转移方程为：

```text
maxend = max(max(maxend * a[i], minend * a[i]), a[i]);
minend = min(min(maxend * a[i], minend * a[i]), a[i]);  
```



```c++
int maxSuccessiveProduct(int num[], int n)
{
    if(n < 1)
        return INT_MIN;

    int max_prod = num[0], min_prod = num[0];
    int max_res  = max_prod;

    for(int i = 1; i < n; ++i)
    {
        int cur_prod1 = max_prod * num[i];
        int cur_prod2 = min_prod * num[i];

        max_prod = max(max_prod, max(cur_prod1, cur_prod2));
        min_prod = min(min_prod, min(cur_prod1, cur_prod2));

        max_res  = max(max_prod, min_prod);
    }

    return max_res;
}
```





### 最大子数组乘积

给定一个整数数组num，找到具有最大乘积（至少包含一个数字）的子数组。

```text
Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
```



**分析**

使用两个dp数组f[]和g[]，其中f[i]表示子数组[0, i]范围内并且一定包含nums[i]数字的最大子数组乘积，g[i]表示子数组[0, i]范围内并且一定包含nums[i]数字的最小子数组乘积。初始化时f[0]和g[0]都初始化为nums[0]，其余都初始化为0。从数组的第二个数字开始遍历，那么最大值和最小值只会在这三个数字之间产生，即f[i-1] * nums[i]，g[i-1] * nums[i]，和 nums[i]。所以我们用三者中的最大值来更新f[i]，用最小值来更新g[i]. 由于最终的结果不一定会包括nums[n-1]这个数字，所以f[n-1]不一定是最终解，需要不断比较和更新res.

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int res = nums[0], n = nums.size();
        vector<int> f(n, 0), g(n, 0);
        f[0] = nums[0];
        g[0] = nums[0];
        for (int i = 1; i < n; ++i) 
       {
            //和上面的不同在于，外层max的另一个参数是当前元素值
            f[i] = max(max(f[i - 1] * nums[i], g[i - 1] * nums[i]), nums[i]);
            g[i] = min(min(f[i - 1] * nums[i], g[i - 1] * nums[i]), nums[i]);
            res = max(res, f[i]);
        }
        return res;
    }
};
```



### 矩阵链乘法



矩阵乘法定义：只有当矩阵A的列数与矩阵B的行数相等时A×B才有意义。一个m×r的矩阵A左乘一个r×n的矩阵B，会得到一个m×n的矩阵C

所谓矩阵链乘法是指当一些矩阵相乘时，如何加括号来改变乘法顺序从而来降低乘法次数。例如有三个矩阵连乘：A1 * A2 * A3，其维数分别为：10 * 100，100 * 5，5 * 50. 如果按照 ((A1 * A2) * A3) 来计算的话，求(A1 * A2) 要10 * 100 * 5=5000次乘法，再乘以A3需要10 * 5 * 50=2500次乘法，因此总共需要7500次乘法。如果按照(A1 * (A2 * A3)) 来计算的话，求 (A2 * A3)要100 * 5 * 50=25000次乘法，再乘以A1需要10 * 100 * 50=50000次乘法，因此总共需要75000次乘法。可见，按不同的顺序计算，代价相差很大。

矩阵链乘法问题可以表述如下：给定n个矩阵构成的一个链（A1 * A2 * A3 * …… * An），其中i=1,2,……n, 矩阵Ai的维数为p(i-1) * p(i), 对于乘积A1 * A2 * A3 * …… * An 以一种最小化标量乘法次数的方式进行加括号。



**分析**

设计算A[i:j]，1 ≤ i ≤ j ≤ n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]。

当 i=j 时，A[i:j]=Ai，因此，m[i] [i]=0，i=1,2,…,n

当 i<j 时，若A[i:j]的最优次序在A[k]和A[k+1]之间断开，i<=k<j, 则 m[i] [j] = m[i] [k]+m[k+1] [j]+p(i-1) * p(k) * p(j). 由于在计算时并不知道断开点k的位置，所以k还未定。不过k的位置只有j-i个可能。因此，k是这j-i个位置使计算量达到最小的那个位置。

综上得到递推关系如下：
$$
m[i, j]=\left\{\begin{array}{cc}
0 & i=j \\
\min \left\{m[i, k]+m[k+1, j]+p_{i-1} p_{k} p_{j}\right\} & i<j
\end{array}\right.
$$


构造最优解：

若将对应m[i] [j]的最优断开位置k记为s[i] [j]，在计算出最优值m[i] [j]后，可递归地由s[i] [j]构造出相应的最优解。s[i] [j]中的数表明，计算矩阵链A[i:j]的最佳方式应在矩阵A[k]和A[k+1之间断开]，即最优的加括号方式应为(A[i:k])(A[k+1:j)。因此，从s[1] [n]记录的信息可知计算A[1:n]的最优加括号方式为(A[1:s[1] [n]])(A[s[1] [n]+1:n])，进一步递推，A[1:s[1] [n]]的最优加括号方式为(A[1:s[1] [s[1] [n]]])(A[s[1] [s[1] [n]]+1:s[1] [s[1] [n]]])。同理可以确定A[s[1] [n]+1:n]的最优加括号方式在s[s[1] [n]+1] [n]处断开…照此递推下去，最终可以确定A[1:n]的最优完全加括号方式，及构造出问题的一个最优解。



```java
public class MatrixChain {

    private int[] p;
    private int[][] m;
    private int[][] s;
    private int L;

    public MatrixChain(int[] p) {
        this.p = p;
        this.L = p.length;
        this.m = new int[this.L][this.L];
        this.s = new int[this.L][this.L];
    }

    public int optimalValue() {
        return m[1][this.L - 1];
    }

    public void solve() {
        int n = p.length - 1;
        for (int i = 1; i <= n; i++) {
            m[i][i] = 0;
        }

        for (int r = 2; r <= n; r++) { //r为当前计算的链长（子问题规模）
            for (int i = 1; i <= n - r + 1; i++) //n-r+1为最后一个r链的前边界
            {
                int j = i + r - 1; //计算前边界为r，链长为r的链的后边界

                //将链ij划分为A(i)*(A[i+1:j])
                m[i][j] = m[i + 1][j] + p[i - 1] * p[i] * p[j];
                s[i][j] = i;

                for (int k = i + 1; k < j; k++) {
                    //将链ij划分为(A[i:k])*(A[k+1:j])
                    int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                    if (t < m[i][j]) {
                        m[i][j] = t;
                        s[i][j] = k;
                    }
                }
            }
        }
    }

    public void printOptimalParens() {
        printOptimalParens(1, L - 1);
    }


    private void printOptimalParens(int i, int j) {
        if (i == j) {
            System.out.print("A"+i);
        } else {
            System.out.print("(");
            printOptimalParens(i, s[i][j]);
            printOptimalParens(s[i][j] + 1, j);
            System.out.print(")");
        }
    }

    public static void main(String[] args) {
        // /A1 30*35 A2 35*15 A3 15*5 A4 5*10 A5 10*20 A6 20*25  
        int[] p = {30, 35, 15, 5, 10, 20, 25};
        MatrixChain matrixChain = new MatrixChain(p);
        matrixChain.solve();
        System.out.println("最优解是 " + matrixChain.optimalValue());
        matrixChain.printOptimalParens();
    }
}
```





### house-robber

http://www.lintcode.com/zh-cn/problem/house-robber/

 

假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且当相邻的两个房子同一天被打劫时，该系统会自动报警。

给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，在不触动报警装置的情况下， 你最多可以得到多少钱。

即在数组中取出一个或多个不相邻数，使其和最大。

状态转移方程：dp[n] = max(dp[n - 2] + a[n] , dp[n - 1])

其中前一项表示包含a[n]，后一项表示不包含a[n].



```java
long long houseRobber(vector<int> nums) {
  int size = nums.size();
  if (size == 0) {
    return 0;
  }
  if (size == 1) {
    return nums[0];
  }
  if (size == 2) {
    return nums[0] > nums[1] ? nums[0]:nums[1];
  }
  long long n1 = nums[0];
  long long n2 = n1 > nums[1] ? n1 : nums[1];
  long long n3, n4;
  for (int i = 2; i < size; i++) {
    n3 = n1 + nums[i];
    n4 = n3 > n2 ? n3 : n2;
    n1 = n2;
    n2 = n4;
  }
  return n1 > n2 ? n1:n2; // !! 注意此处
}
```



### Largest Independent Set Problem

找一棵树中没有边相连的节点最多有几个

![image-20200314133038663](algorithm/image-20200314133038663.png)



上面这棵树的largest independent set(LIS) is {10, 40, 60, 70, 80} and size of the LIS is 5.

 

**Optimal Substructure:**

Let LISS(X) indicates size of largest independent set of a tree with root X.

LISS(X) = MAX { (1 + sum of LISS for all grandchildren of X),  (sum of LISS for all children of X) }

其实是分两类，一类是和节点X之间接触的，一点和X不接触的。

```java
public static int LISS_Rec(Node root){  
	if(root == null){  
        return 0;  
    }  
          
    // 计算不包含当前节点的size，即为左右孩子的LISS size  
    int sizeExcl = LISS_Rec(root.left) + LISS_Rec(root.right);  
          
    // 计算包含当前节点的size，即为1+孙子的LISS size  
    int sizeIncl = 1;  
    if(root.left != null){  
        sizeIncl += LISS_Rec(root.left.left) + LISS_Rec(root.left.right);  
    }  
    if(root.right != null){  
        sizeIncl += LISS_Rec(root.right.left) + LISS_Rec(root.right.right);  
    }  
          
    return Math.max(sizeExcl, sizeIncl);  
}  
      
public static int LISS_Memo(NodeMemo root){  
    if(root == null){  
        return 0;  
    }  
    if(root.liss != 0){  
        return root.liss;  
    }  
    if(root.left==null && root.right==null){  
        root.liss = 1;  
        return root.liss;  
    }  
          
    int sizeExcl = LISS_Memo(root.left) + LISS_Memo(root.right);  
          
    int sizeIncl = 1;  
    if(root.left != null){  
        sizeIncl += LISS_Memo(root.left.left) + LISS_Memo(root.left.right);  
    }  
    if(root.right != null){  
        sizeIncl += LISS_Memo(root.right.left) + LISS_Memo(root.right.right);  
    }  
          
    root.liss = Math.max(sizeExcl, sizeIncl); // 保存结果  
    return root.liss;  
}  
```





### 三角形最小路径和

给定一个三角形，找出自顶向下的最小路径和，其中每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

[

​		[2],

​       [3,4],

​      [6,5,7],

​     [4,1,8,3]

]

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。



**我们使用数组来定义三角形，如下图。如此题目中给出的条件——每一步只能移动到下一行中相邻的结点上，等同于，每一步只能往下移动一格或者右下移动一格。**

<img src="algorithm/Image 7.png" style="zoom:33%;" />

定义状态如下：

$dp[i] [j]$ : 表示包含第i行j列元素的最小路径和

则状态转移方程为：

$dp[i] [j] = min(dp[i-1] [j-1],dp[i-1] [j]) + triangle[i] [j]$

初始状态为：$dp[0] [0] = [0] [0]$位置所在的元素值。

此外，还需要注意最左边的元素只能从上边而来，而最右边的元素只能从左上角而来。

最后，我们只要找到最后一行元素中，路径和最小的一个就是所要求的解。

```go
func minimumTotal(triangle [][]int) int {
    if len(triangle) < 1 {
        return 0
    }
    if len(triangle) == 1 {
        return triangle[0][0]
    }
    dp := make([][]int, len(triangle))
    for i, arr := range triangle {
        dp[i] = make([]int, len(arr))
    }
    result := 1<<31 - 1
    dp[0][0] = triangle[0][0]
    dp[1][1] = triangle[1][1] + triangle[0][0]
    dp[1][0] = triangle[1][0] + triangle[0][0]
    for i := 2; i < len(triangle); i++ {
        for j := 0; j < len(triangle[i]); j++ {
            if j == 0 {
                dp[i][j] = dp[i-1][j] + triangle[i][j]
            } else if j == (len(triangle[i]) - 1) {
                dp[i][j] = dp[i-1][j-1] + triangle[i][j]
            } else {
                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]
            }
        }  
    }
    for _,k := range dp[len(dp)-1] {
        result = min(result, k)
    }
    return result
}

func min(a, b int) int {
    if a > b {
        return b
    }
    return a
}
```









### *最大长方形 Largest Rectangle

http://www.csie.ntnu.edu.tw/~u91029/MaximumSubarray.html#2

![image-20200314132716998](algorithm/image-20200314132716998.png)

一张方格纸，许多格子填入黑色。请找出不包含黑格子的矩形，令矩形面积尽量大。

穷举法：穷举所有矩形（使用对角线定点），时间复杂度是O((HW)²) ，然后确认矩形不含黑格子，总的时间复杂度就是O((HW)³) 。

如果预先计算二维前缀和，就能迅速计算二维区间和，时间复杂度是O(HW) 。穷举所有矩形，同时确认矩形不含黑格子：判断矩形面积与区间和是否相等，就是O((HW)²)

![image-20200314132846105](algorithm/image-20200314132846105.png)

在每一行上计算Largest Empty Interval，只要使用前缀和即可，然后穷举以固定某点为右下角顶点的矩形（如上图中黄色的点），计算矩形面积。时间复杂度是O((HW)H) 。

空间复杂度分析：储存全部问题的答案，空间复杂度是O(HW)

也可以改为切竖条，然后穷举矩形右上角顶点。

为了不超出边界、导致溢位，在纸张外面多围一圈。这是处理二维地图的常见手法。

![image-20200314132913812](algorithm/image-20200314132913812.png)



```java
bool array[ 10+2][10+2];
int width[ 10+2][10+2];

int largest_empty_rectangle() {

    // 计算所有横条当中，每个位置往左可延伸的长度。0表示黑格子 
    for (int i = 1; i <= 10; ++i)
        for (int j = 1; j <= 10; ++j)
            if (array[i][j])
                width[i][j] = width[i][j - 1] + 1;
            else
                width[i][j] = 0;

    // 计算每个位置当作矩形右下角顶点时的最大矩形面积。

    // 最大矩形面积，初始化为最小值
    int area = 0;

    // 穷举矩形右下角顶点的位置
    for (int i = 1; i <= 10; ++i)
        for (int j = 1; j <= 10; ++j) {
            int w = 1e9;
            for (int h = 1; i - h + 1 >= 0; ++h) {
                if (width[i - h + 1][j] == 0) break;
                // 宽度应该选择w[i][j],w[i-1][j],...w[i-(h-1)][j]中最小的
                w = min(w, width[i - h + 1][j]);
                area = max(area, w * h);
            }
        }

    return area;
}
```





**另一种解法**



首先如下图所示，在表T中记录各元素向上存在多少个连续的白色各自。对各列使用动态规划法可以轻松地求出T.

![image-20200314225810884](algorithm/image-20200314225810884.png)

我们把表T的每行都看成一个直方图，本题就成了求直方图内最大长方形的问题。于是问题转为求直方图中最大长方形的面积。这里最容易想到的仍然是穷举法，我们可以列出直方图的所有端点，求出各个范围内的最大长方形的面积(以该范围内最小值为高的长方形的面积)，然后取其中最大值。但是，这样整体的复杂度仍高达O($H W^{2}$)或O($H^{2} W$)。



其实在解这个问题的时候，只要用栈替代数组记录局部问题的解，就能大幅提高求最优解的效率。栈中记录“仍有可能扩张的长方形的信息(记为rect"。rect内含有两个信息，一个是长方形的高 height，另一个是其左端的位置pos。首先我们将栈置为空，接下来对于直方图的各个值Hi(i=0,1, …, W-1)，创建以Hi为高，以其下标i为左端位置的长方形rect，然后进行以下处理。

1. 如果栈为空。将rect压入栈。
2. 如果栈顶长方形的高小于rect的高。将rect压入栈。
3. 如果栈顶长方形的高等于rect的高。不作处理。
4. 如果栈顶长方形的高大于rect的高。
   - 只要栈不为空，且栈顶长方形的高大于等于rect的高，就从栈中取出长方形，同时计算其面积并更新最大值。长方形的长等于“当前位置i”与之前记录的“左端位置pos”的差值。
   - 将rect压人栈。另外，**这个rect的左端位置pos为最后从栈中取出的长方形的pos值**。



<img src="algorithm/1.png" alt="借助栈检测最大长方形" style="zoom: 50%;" />



```java
public class DP_LargestRectangle {

    public static class Rectangle {

        public int height;

        public int pos;

        public Rectangle(int height, int pos) {
            this.height = height;
            this.pos = pos;
        }
    }
    
    // 求直方图内最大长方形
    public static int getLargestRectangle(int[] heights) {

        Stack<Rectangle> stack = new Stack<>();

        int maxArea = 0;

        int[] buffer = new int[heights.length + 1];
        System.arraycopy(heights, 0, buffer, 0, heights.length);
        // 在最后添加一个0，否则比如heights是递增的情况就不会有出栈的操作，所以得不到结果。
        buffer[heights.length] = 0;

        for (int i = 0; i < buffer.length; i++) {
            Rectangle rect = new Rectangle(buffer[i], i);

            if (stack.isEmpty()) {
                stack.push(rect);
            } else if (stack.peek().height < rect.height) {
                stack.push(rect);
            } else if (stack.peek().height > rect.height) {
                Rectangle topRect = null;
                while (stack.peek().height > rect.height) {
                    topRect = stack.pop();
                    int area = topRect.height * (i - topRect.pos);
                    maxArea = Math.max(area, maxArea);
                }
                rect.pos = topRect.pos;
                stack.push(rect);
            }
        }

        return maxArea;
    }


    public int H, W;
    public int[][] buffer;
    public int[][] T;

    public int getLargestRectangle() {

        for (int j = 0; j < W; j++) {
            for (int i = 0; i < H; i++) {
                if (buffer[i][j] == 0) { // 为0表示白色
                    T[i][j] = i > 0 ? T[i - 1][j] + 1 : 1;
                } else {
                    T[i][j] = 0;
                }
            }
        }

        int maxArea = 0;
        for (int i = 0; i < H; i++) {
            maxArea = Math.max(maxArea, getLargestRectangle(T[i]));
        }

        return maxArea;
    }
 
}
```







### 零钱兑换II和爬楼梯问题到底有什么不同？

在LeetCode上有两道题目非常类似，分别是

[70.爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

[518.零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

如果我们把每次可走步数/零钱面额限制为[1,2], 把楼梯高度/总金额限制为3. 那么这两道题目就可以抽象成"给定[1,2], 求组合成3的组合数和排列数"。接下来引出本文的核心两段代码。

```c++
public:
    int change(int amount, vector<int>& coins) {
        int dp[amount+1];
        memset(dp, 0, sizeof(dp)); //初始化数组为0
        dp[0] = 1;
        for (int j = 1; j <= amount; j++){ //枚举金额
            for (int coin : coins){ //枚举硬币
                if (j < coin) continue; // coin不能大于amount
                dp[j] += dp[j-coin];
            }
        }
        return dp[amount];
    }
};

class Solution2 {
public:
    int change(int amount, vector<int>& coins) {
        int dp[amount+1];
        memset(dp, 0, sizeof(dp)); //初始化数组为0
        dp[0] = 1;
        for (int coin : coins){ //枚举硬币
            for (int j = 1; j <= amount; j++){ //枚举金额
                if (j < coin) continue; // coin不能大于amount
                dp[j] += dp[j-coin];
            }
        }
        return dp[amount];
    }
};
```

 

如果不仔细看，你会觉得这两个Solution似乎是一模一样的代码，但细心一点你会发现他们在嵌套循环上存在了差异。这个差异使得一个求解结果是排列数，一个求解结果是组合

 

#### 爬楼梯
问题描述如下:

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

这道题目子问题是，problem(i) = sub(i-1) + sub(i-2)， 即求解第i阶楼梯等于求解第i-1阶楼梯和第i-2阶楼梯之和。

状态数组是 DP[i], 状态转移方程是DP[i] = DP[i-1] = DP[i-2]

那么代码也就可以写出来了。

```
class Solution {
public:
    int climbStairs(int n) {
        int DP[n+1];
        memset(DP, 0, sizeof(DP));
        DP[0] = 1;
        DP[1] = 1;
        for (int i = 2; i <= n; i++){
            DP[i] = DP[i-1] + DP[i-2] ;
        }
        return DP[n];

	}
};
```
由于每次我们只关注DP[i-1]和DP[i-2]，所以代码中能把数组替换成2个变量，降低空间复杂度，可以认为是将一维数组降维成点。

如果把问题泛化，不再是固定的1,2，而是任意给定台阶数，例如1,2,5呢？我们只需要修改我们的DP方程DP[i] = DP[i-1] + DP[i-2] + DP[i-5], 也就是DP[i] = DP[i] + DP[i-j] ,j =1,2,5

在原来的基础上，我们的代码可以做这样子修改

```
class Solution {
public:
    int climbStairs(int n) {
        int DP[n+1];
        memset(DP, 0, sizeof(DP));
        DP[0] = 1;
        int steps[2] = {1,2};
        for (int i = 1; i <= n; i++){
            for (int j = 0; j < 2; j++){
                int step = steps[j];
                if ( i < step ) continue;// 台阶少于跨越的步数
                DP[i] = DP[i] + DP[i-step];
            }
        }
        return DP[n];

    }
};
```
后续修改steps数组，就实现了原来问题的泛化。

那么这个代码是不是看起来很眼熟呢？我们能不能交换内外的循环呢？也就是下面的代码
```
for (int j = 0; j < 2; j++){
    int step = steps[j];
    for (int i = 1; i <= n; i++){
        if ( i < step ) continue;// 台阶少于跨越的步数
         DP[i] = DP[i] + DP[i-step];
    }
}
```
大家可以尝试思考下这个问题，嵌套循环是否能够调换，调换之后的DP方程的含义有没有改变？




#### 零钱兑换II

问题描述如下:

给定不同面额的硬币和一个总金额。求可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

定义子问题: problem(i) = sum( problem(i-j) ), j =1,2,5. 含义为凑成总金额i的硬币组合数等于凑成总金额硬币i-1, i-2, i-5,...的子问题之和。

我们发现这个子问题定义居然和我们之前泛化的爬楼梯问题居然是一样的，那后面的状态数组和状态转移方程也是一样的，所以当前问题的代码可以在之前的泛化爬楼梯问题中进行修改而得。

```
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int dp[amount+1];
        memset(dp, 0, sizeof(dp)); //初始化数组为0
        dp[0] = 1;
        for (int j = 1; j <= amount; j++){ //枚举金额
            for (int i = 0; i < coins.size(): i++){ 
                int coin = coins[i]; //枚举硬币
                if (j < coin) continue; // coin不能大于amount
                dp[j] += dp[j-coin];
            }
        }
        return dp[amount];
    }
};
```

这就是我们之前的Solution1代码。

但是当你运行之后，却发现这个代码并不正确，得到的结果比预期的大。究其原因，该代码计算的结果是排列数，而不是组合数，也就是代码会把1,2和2,1当做两种情况。但更加根本的原因是我们子问题定义出现了错误。

正确的子问题定义应该是，problem(k,i) = problem(k-1, i) + problem(k, i-k)
即前k个硬币凑齐金额i的组合数等于前k-1个硬币凑齐金额i的组合数加上在原来i-k的基础上使用第k个硬币的组合数。说的更加直白一点，那就是用前k的硬币凑齐金额i，要分为两种情况开率，一种是只用前k-1个硬币就凑齐了，一种是前面已经凑到了i-k，现在就差第k个硬币了。

状态数组就是DP\[k][i], 即前k个硬币凑齐金额i的组合数。这里不再是一维数组，而是二维数组。第一个维度用于记录当前组合有没有用到硬币k，第二个维度记录现在凑的金额是多少。如果没有第一个维度信息，当我们凑到金额i的时候，我们不知道是否用到硬币k。

因为这是个组合问题，我们不关心硬币使用的顺序，而是硬币有没有被用到。是否使用第k个硬币受到之前情况的影响。

状态转移方程如下：
if 金额数大于硬币
    DP\[k][i] = DP\[k-1][i] + DP\[k][i-k]
else
    DP\[k][i] = DP\[k-1][i]
因此正确代码如下:

```
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int K = coins.size() + 1;
        int I = amount + 1;
        int DP[K][I];
        //初始化数组
        for (int k = 0; k < K; k++){
            for (int i = 0; i < I; i++){
                DP[k][i] = 0;
            }
        }
        //初始化基本状态
        for (int k = 0; k < coins.size() + 1; k++){
            DP[k][0] = 1;
        }
        for (int k = 1; k <= coins.size() ; k++){
            for (int i = 1; i <= amount; i++){  
                if ( i >= coins[k-1]) {
                    DP[k][i] = DP[k][i-coins[k-1]] + DP[k-1][i]; 
                } else{
                    DP[k][i] = DP[k-1][k];
                }
            }
        }
        return DP[coins.size()][amount];
    }
};
```

我们初始化的数组大小为coins.size()+1* (amount+1), 这是因为第一列是硬币为0的基本情况。

此时，交换这里面的循环不会影响最终的结果。也就是
```
for (int i = 1; i <= amount; i++){  
    for (int k = 1; k <= coins.size() ; k++){ 
        if ( i >= coins[k-1]) {
            DP[k][i] = DP[k][i-coins[k-1]] + DP[k-1][i]; 
         } else{
             DP[k][i] = DP[k-1][k];
         }
     }
}
```
之前爬楼梯问题中，我们将一维数组降维成点。这里问题能不能也试着降低一个维度，只用一个数组进行表示呢？此时需要重新定义我们的子问题：对于硬币从0到k，我们必须使用第k个硬币的时候，当前金额的组合数。因此状态数组DP[i]表示的是对于第k个硬币能凑成的组合数。状态转移方程为：DP[[i] = DP[i] + DP[i-k]，于是得到我们开头的第二个Solution。
```
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int dp[amount+1];
        memset(dp, 0, sizeof(dp)); //初始化数组为0
        dp[0] = 1;
        for (int coin : coins){ //枚举硬币
            for (int i = 1; i <= amount; i++){ //枚举金额
                if (i < coin) continue; // coin不能大于amount
                dp[i] += dp[i-coin];
            }
        }
        return dp[amount];
    }
};
```
那这里的内外循环能换吗？显然不能，因为我们这里定义的子问题是，必须选择第k个硬币时，凑成金额i的方案。如果交换了，我们的子问题就变了，那就是对于金额i, 我们选择硬币的方案。

同样的，我们回答之前爬楼梯的留下的问题，原循环结构对应的子问题是，对于楼梯数i, 我们的爬楼梯方案。第二种循环结构则是，固定爬楼梯的顺序，我们爬楼梯的方案。也就是第一种循环下，对于楼梯3，你可以先2再1，或者先1再2，但是对于第二种循环





### Jerry的异或运算

Jerry 最近在研究异或运算，异或也叫半加运算，其运算法则相当于不带进位的二进制加法。

Jerry 给你一个数字N，他想知道在0 到N 之间有多少对数字(a,b) 满足u+v=a, u ⊕ v = b, ⊕ 表示按位异或，由于答案将会非常大，请将结果对1e9+7 取模。



**分析**：

由于 u+v=a,u ⊕ v = b, 根据异或的性质我们可以知道：u+v = ((u&v)<<1) + (u ⊕ v)，所以u+v >=u ⊕ v，那么只要u+v<=n, u ⊕ v 也必定小于等于n 。于是这道题就转化成了对于 u+v<=n , 求(u,v) 的对数。

定义dp[n] 表示 满足u+v<=n 的 (u,v) 对数， 当n=0 的时候dp[0] = 1；n=1 时， dp[1] = 2。他们的(u,v) 分别是{(0,0)} 和{(0,0), (1,0)}。

dp[n] 再往下递推的时候，要考虑u+v<=n 时**二进制是如何由小到大转化过来的**。

从二进制上来看u 和v，两者的末位只有0 或1，那么二者的末位和有0,1,2 三种情况。

设u+v=x，令u = u1\*2+u0，v = v1 \*2+v0，u0+v0 即为二者的末位和，又由x<=n，故(u1+v1)*2+u0+v0<=n, 所以u1+u2<=(n-u0-v0)/2。

由u1+u2<=(n-u0-v0)/2 到(u1+v1)*2+u0+v0<=n 可以推出来递推式：dp[n] = dp[n/2]+dp[(n-1)/2]+dp[(n-2)/2]。





### 最长等差序列

把公差也作为状态的一维，但是要注意差值有可能为负，因为数组访问的索引是需要大于等于0的，所以需要把公差统一加上一个最大值。

```java
public class LeetCode1027 {
    
	public static int longestArithSeqLength(int[] nums) {
       
        if (nums.length <= 2) return nums.length;

        int invalid = Integer.MIN_VALUE;
        int drift = 10000;
        int[][] dp = new int[nums.length][20001]; // 以dp[i]结尾公差为j的最长等差序列
        for(int i=0; i<dp.length; i++) {
            for(int j=0; j<dp[0].length; j++) {
                dp[i][j] = invalid;
            }
        }
        dp[1][nums[1] - nums[0] + drift] = 2;

        for (int i = 2; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                int diff = nums[i]-nums[j]+drift;
                dp[i][diff] = 2;
                if(dp[j][diff] != invalid) {
                    dp[i][diff] = Math.max(dp[i][diff], dp[j][diff] + 1);
                }
            }
        }

        int ans = 2;
        for(int i=0; i<dp.length; i++) {
            for(int j=0; j<dp[0].length; j++) {
               ans = Math.max(ans, dp[i][j]);
            }
        }

        return ans;
    }

}
```



优化版本

```java
public class LeetCode1027 {

    public static int longestArithSeqLength(int[] nums) {

        if (nums.length <= 2) return nums.length;

        int invalid = Integer.MIN_VALUE;
        int drift = 10000;
        int[][] dp = new int[nums.length][20001]; // 以dp[i]结尾公差为j的最长等差序列
        for(int i=0; i<dp.length; i++) {
            for(int j=0; j<dp[0].length; j++) {
                dp[i][j] = invalid;
            }
        }
        dp[1][nums[1] - nums[0] + drift] = 2;

        int ans = 2;

        for (int i = 2; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                int diff = nums[i]-nums[j]+drift;
                dp[i][diff] = 2;
                if(dp[j][diff] != invalid) {
                    dp[i][diff] = Math.max(dp[i][diff], dp[j][diff] + 1);
                }
                ans = Math.max(ans, dp[i][diff]);
            }
        }

        return ans;
    }

}
```



### 寻找等比数列 TODO

再给定数组中，查找三个能组成公比为k的等比数列，且不能改变三个数在数组中的位置。求数组中一共有多少个这样的等比数列。



### 字符匹配

给你一个字符串，字符串中仅包含"A","B", 现在有四种字符串"AA","AB","BA","BB"，每种字符串都有他们的权值，问从给出的字符串中能够得到的最大权值为多少( 一个字符只能属于一个子字符串) ？

输入一个字符串s（1 <= |s| <=10^6）;
再输入一个数组，数组中包含四个数字a,b,c,d，依次表示字符串"AA","AB", "BA","BB" 的权值(1 <= a,b,c,d <= 100)。



**分析**：

定义一个字典map，key 分别为"AA","AB","BA","BB"，value 为对应的权值。

定义大小为n的数组dp，dp[i] 表示前i 个字符组成的最大权值，那么dp[0]=0，dp[1]=map.get(s.substring(0, 2));

从i=2 开始遍历字符串，对于dp[i]，有两个选择，一种是让第i 个字符独立，即此时的权值dp[i]=dp[i-1]，因为第i 个字符没有创造价值。
另一种选择是让第i 个字符有价值，即第i-1 个字符和第i 个字符组合创造价值，此时dp[i]=dp[i-2] + map.get(s.substring(i-1,i+1)). 针对这两个选择，取权值最大的即可。

因此，dp[n-1] 为最终答案。



### 数组的最大连续递增子区间

给定数组，允许删除至多一个元素，求此种情况下的连续最长递增子区间。

```java
class GFG {
    
	static int maxIncSubArr(int a[], int n) {
        // Create two arrays pre and pos
        int pre[] = new int[n];
        int pos[] = new int[n];
        pre[0] = 1;
        pos[n - 1] = 1;
        int l = 0;

        // Find out the contribution of the current
        // element in array[0, i] and update pre[i]
		// pre[] 形如 1,2,1,2,3,4,1,2,3即各个递增的子区间
        for (int i = 1; i < n; i++) {
            if (a[i] > a[i - 1])
                pre[i] = pre[i - 1] + 1;
            else
                pre[i] = 1;
        }

        // Find out the contribution of the current
        // element in array[N - 1, i] and update pos[i]
        l = 1;
		// post[] 形如 3,2,1,2,1即各个递减的子区间（或者说反向递增）
        for (int i = n - 2; i >= 0; i--) {
            if (a[i] < a[i + 1])
                pos[i] = pos[i + 1] + 1;
            else
                pos[i] = 1;
        }

        // Calculate the maximum length of the strictly increasing 
		// subarray without removing any element
        int ans = 0;
        l = 1;
        for (int i = 1; i < n; i++) {
            if (a[i] > a[i - 1])
                l++;
            else
                l = 1;
            ans = Math.max(ans, l);
        }

        // Calculate the maximum length of the strictly increasing subarray 
		// after removing the current element
        for (int i = 1; i <= n - 2; i++) {
            if (a[i - 1] < a[i + 1])
				// 去掉元素a[i], a[i]前面有pre[i-1]元素，后面有post[i+1]个递增元素
                ans = Math.max(pre[i - 1] + pos[i + 1], ans);
        }
        return ans;
    }

    // Driver code
    public static void main(String[] args) {
        int arr[] = {5, 10, 6, 7, 8};
        int n = arr.length;
        System.out.println(maxIncSubArr(arr, n));
    }
}
```











### 奇偶数列 TODO

**Garland CodeForces - 1287C**



给一个1-n的数字序列，某些数字被移除，请重新填写这些数字使得一奇一偶的对数最少。



**分析**：

记`dp[i][j][0]`和`dp[i][j][1]`分别为第i个为奇数/偶数且前i个里面有j个偶数的情况下，第i个的最小复杂度；
很容易得到第i个是奇数/偶数时的递推关系；当第i个是空着时，它取奇偶皆可。因此得到如下递推式：

```
当前位置为偶数或0
dp[i][j][0]=min(dp[i-1][j-1][0],dp[i][j][0]);
dp[i][j][0]=min(dp[i-1][j-1][1]+1,dp[i][j][0]);
 
当前位置为奇数或0
dp[i][j-1][1]=min(dp[i-1][j-1][1],dp[i][j-1][1]);
dp[i][j-1][1]=min(dp[i-1][j-1][0]+1,dp[i][j-1][1]);

```

最终答案就是前n个数中偶数为n/2个的情况下，取`[0]`和`[1]`的最小值。



```java
int solve(int[] a, int n) { // a的下标从1开始
    int[][][] dp = new int[n + 1][n + 1][2];
    for (int i = 0; i < dp.length; i++) {
        for (int j = 0; j < dp[0].length; j++) {
            for (int k = 0; k < dp[0][0].length; k++) {
                dp[i][j][k] = n;
            }
        }
    }
    dp[0][0][0] = 0;
    dp[0][0][1] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n / 2 + 1; j++) {
            if (a[i] % 2 == 0 || a[i] == 0) {
                dp[i][j][0] = Math.min(dp[i - 1][j - 1][0], dp[i][j][0]);
                dp[i][j][0] = Math.min(dp[i - 1][j - 1][1] + 1, dp[i][j][0]);
            }
            if (a[i] % 2 == 1 || a[i] == 0) {
                dp[i][j - 1][1] = Math.min(dp[i - 1][j - 1][1], dp[i][j - 1][1]);
                dp[i][j - 1][1] = Math.min(dp[i - 1][j - 1][0] + 1, dp[i][j - 1][1]);
            }
        }
    }
    return Math.min(dp[n][n / 2][0], dp[n][n / 2][1]);
}
```





## 图相关





### 构建凸包（Convex Hull）



给定平面上的点集，该点集的凸包是包含其所有点的最小凸多边形。



Jarvis算法：

1. 将p初始化为最左点
2. 一直循环以下操作直到回到起始点
   1. 取下一个点q，使得对于任何其他点r，有序的点的三元组(p，q，r）都是逆时针
   2. next[p] = q
   3. p = q



<img src="algorithm/JarvisAlgorithm.png" alt="img" style="zoom: 80%;" />





有序的点的三元组的方向

<img src="algorithm/linesegments.png" alt="img" style="zoom: 80%;" />

```java
public class ConvexHull {

    static class Point {
        int x, y;

        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    // To find orientation of ordered triplet (p, q, r).
    // The function returns following values
    // 0 --> p, q and r are colinear
    // 1 --> Clockwise
    // 2 --> Counterclockwise
    public static int orientation(Point p, Point q, Point r) {
        int val = (q.y - p.y) * (r.x - q.x) -
                (q.x - p.x) * (r.y - q.y);

        if (val == 0) return 0;  // collinear
        return (val > 0) ? 1 : 2; // clock or counterclock wise
    }

    // Prints convex hull of a set of n points.
    public static void convexHull(Point points[], int n) {
        // There must be at least 3 points
        if (n < 3) return;

        // Initialize Result
        Vector<Point> hull = new Vector<>();

        // Find the leftmost point
        int l = 0;
        for (int i = 1; i < n; i++)
            if (points[i].x < points[l].x)
                l = i;

        // Start from leftmost point, keep moving
        // counterclockwise until reach the start point
        // again. This loop runs O(h) times where h is
        // number of points in result or output.
        int p = l, q;
        do {
            // Add current point to result
            hull.add(points[p]);

            // Search for a point 'q' such that
            // orientation(p, x, q) is counterclockwise
            // for all points 'x'. The idea is to keep
            // track of last visited most counterclock-
            // wise point in q. If any point 'i' is more
            // counterclock-wise than q, then update q.
            q = (p + 1) % n;

            for (int i = 0; i < n; i++) {
                // If i is more counterclockwise than
                // current q, then update q
                if (orientation(points[p], points[i], points[q]) == 2)
                    q = i;
            }

            // Now q is the most counterclockwise with
            // respect to p. Set p as q for next iteration,
            // so that q is added to result 'hull'
            p = q;

        } while (p != l);  // While we don't come to first
 
        for (Point temp : hull)
            System.out.println("(" + temp.x + ", " + temp.y + ")");
    }
    
}
```





### 用BFS求最短路径

假设有一个网格迷宫，由n行m列的单元格组成，每个单元格要么是空地，要么是障碍物。如何找到从起点到终点的最短路径？考虑二叉树的BFS，结点的访问顺序恰好是它们到根结点距离从小到大的顺序。类似地，也可以用BFS来按照到起点的距离顺序遍历迷宫图。

例如，假定起点在左上角，就从左上角开始用BFS遍历迷宫图，逐步计算出它到每个结点的最短路距离（如下图(a)所示），以及这些最短路径上每个结点的“前一个结点”（如下图(b)所示）。

<img src="algorithm/1607006099000.png" alt="1607006099000" style="zoom: 33%;" />

注意，如果把上图(b)中的箭头理解成“指向父亲的指针”，那么迷宫中的格子就变成了一棵树一一除了起点外，每个结点恰好有一个父亲。





## 数理逻辑

## 模数求和

现给定n个整数，并定义一个非负整数m，且令f(m) = (m%a1)+(m%a2)+...+(m%an)。
此处的X % Y的结果为X除以Y的余数。
现请你找出一个m，求出f(m)的最大值。

示例
输入
3
3 4 6
输出
10



**我的解法**

```java
public class Main {
	// 最大公约数
    public static int gcd(int x, int y) {
        if (y > x) {
            int temp = x;
            x = y;
            y = temp;
        }

        if (x % y == 0) {
            return y;
        }
        int t = x % y;
        return gcd(y, t);
    }

    // 最小公倍数
    public static int lcm(int x, int y) {
        return x * y / gcd(x, y);
    }
    
    // 暴力搜索1到所有数字的最小公倍数
    public static int solve(int n, int[] arr) {
        if (arr.length == 1) {
            return arr[0] - 1;
        }
        int lcm = lcm(arr[0], arr[1]);
        for (int i = 2; i < arr.length; i++) {
            lcm = lcm(lcm, arr[i]);
        }
        int max = -1;
        for (int i = 1; i <= lcm; i++) {
            int sum = 0;
            for (int j = 0; j < n; j++) {
                sum += i % arr[j];
            }
            if (sum > max) {
                max = sum;
            }
        }
        return max;
    }
}
```



最优解

```
# 假设 m % x = x-1（x-1是能取到的最大余数，也就是说 m+1 是 x 的倍数）
# 如果 m+1 是所有数的倍数，则 f(m) 可以取到最大值，m+1 的值就是所有数的最小公倍数（TODO）
# f(m) = (a1-1) + (a2-1) + ... + (an-1) = sum(a)-n
n ``=` `int``(``input``())
a ``=` `list``(``map``(``int``, ``input``().split(``' '``)))
print``(``sum``(a) ``-` `n)
```















